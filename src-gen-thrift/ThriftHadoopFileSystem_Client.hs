{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.3)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ThriftHadoopFileSystem_Client(setInactivityTimeoutPeriod,shutdown,create,createFile,open,append,write,read,closeReadHandle,closeWriteHandle,rm,rename,mkdirs,exists,stat,listStatus,chmod,chown,setReplication,getFileBlockLocations) where
import qualified Data.IORef as R
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Hadoopfs_Types
import ThriftHadoopFileSystem
seqid = R.newIORef 0
setInactivityTimeoutPeriod (ip,op) arg_periodInSeconds = do
  send_setInactivityTimeoutPeriod op arg_periodInSeconds
  recv_setInactivityTimeoutPeriod ip
send_setInactivityTimeoutPeriod op arg_periodInSeconds = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("setInactivityTimeoutPeriod", T.M_CALL, seqn)
  write_SetInactivityTimeoutPeriod_args op (SetInactivityTimeoutPeriod_args{setInactivityTimeoutPeriod_args_periodInSeconds=arg_periodInSeconds})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_setInactivityTimeoutPeriod ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_SetInactivityTimeoutPeriod_result ip
  T.readMessageEnd ip
  P.return ()
shutdown (ip,op) arg_status = do
  send_shutdown op arg_status
  recv_shutdown ip
send_shutdown op arg_status = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("shutdown", T.M_CALL, seqn)
  write_Shutdown_args op (Shutdown_args{shutdown_args_status=arg_status})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_shutdown ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Shutdown_result ip
  T.readMessageEnd ip
  P.return ()
create (ip,op) arg_path = do
  send_create op arg_path
  recv_create ip
send_create op arg_path = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("create", T.M_CALL, seqn)
  write_Create_args op (Create_args{create_args_path=arg_path})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_create ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Create_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (create_result_ouch res)
  P.return $ create_result_success res
createFile (ip,op) arg_path arg_mode arg_overwrite arg_bufferSize arg_block_replication arg_blocksize = do
  send_createFile op arg_path arg_mode arg_overwrite arg_bufferSize arg_block_replication arg_blocksize
  recv_createFile ip
send_createFile op arg_path arg_mode arg_overwrite arg_bufferSize arg_block_replication arg_blocksize = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("createFile", T.M_CALL, seqn)
  write_CreateFile_args op (CreateFile_args{createFile_args_path=arg_path,createFile_args_mode=arg_mode,createFile_args_overwrite=arg_overwrite,createFile_args_bufferSize=arg_bufferSize,createFile_args_block_replication=arg_block_replication,createFile_args_blocksize=arg_blocksize})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_createFile ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_CreateFile_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (createFile_result_ouch res)
  P.return $ createFile_result_success res
open (ip,op) arg_path = do
  send_open op arg_path
  recv_open ip
send_open op arg_path = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("open", T.M_CALL, seqn)
  write_Open_args op (Open_args{open_args_path=arg_path})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_open ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Open_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (open_result_ouch res)
  P.return $ open_result_success res
append (ip,op) arg_path = do
  send_append op arg_path
  recv_append ip
send_append op arg_path = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("append", T.M_CALL, seqn)
  write_Append_args op (Append_args{append_args_path=arg_path})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_append ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Append_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (append_result_ouch res)
  P.return $ append_result_success res
write (ip,op) arg_handle arg_data = do
  send_write op arg_handle arg_data
  recv_write ip
send_write op arg_handle arg_data = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("write", T.M_CALL, seqn)
  write_Write_args op (Write_args{write_args_handle=arg_handle,write_args_data=arg_data})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_write ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Write_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (write_result_ouch res)
  P.return $ write_result_success res
read (ip,op) arg_handle arg_offset arg_size = do
  send_read op arg_handle arg_offset arg_size
  recv_read ip
send_read op arg_handle arg_offset arg_size = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("read", T.M_CALL, seqn)
  write_Read_args op (Read_args{read_args_handle=arg_handle,read_args_offset=arg_offset,read_args_size=arg_size})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_read ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Read_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (read_result_ouch res)
  P.return $ read_result_success res
closeReadHandle (ip,op) arg_out = do
  send_closeReadHandle op arg_out
  recv_closeReadHandle ip
send_closeReadHandle op arg_out = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("closeReadHandle", T.M_CALL, seqn)
  write_CloseReadHandle_args op (CloseReadHandle_args{closeReadHandle_args_out=arg_out})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_closeReadHandle ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_CloseReadHandle_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (closeReadHandle_result_ouch res)
  P.return $ closeReadHandle_result_success res
closeWriteHandle (ip,op) arg_out = do
  send_closeWriteHandle op arg_out
  recv_closeWriteHandle ip
send_closeWriteHandle op arg_out = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("closeWriteHandle", T.M_CALL, seqn)
  write_CloseWriteHandle_args op (CloseWriteHandle_args{closeWriteHandle_args_out=arg_out})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_closeWriteHandle ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_CloseWriteHandle_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (closeWriteHandle_result_ouch res)
  P.return $ closeWriteHandle_result_success res
rm (ip,op) arg_path arg_recursive = do
  send_rm op arg_path arg_recursive
  recv_rm ip
send_rm op arg_path arg_recursive = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("rm", T.M_CALL, seqn)
  write_Rm_args op (Rm_args{rm_args_path=arg_path,rm_args_recursive=arg_recursive})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_rm ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Rm_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (rm_result_ouch res)
  P.return $ rm_result_success res
rename (ip,op) arg_path arg_dest = do
  send_rename op arg_path arg_dest
  recv_rename ip
send_rename op arg_path arg_dest = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("rename", T.M_CALL, seqn)
  write_Rename_args op (Rename_args{rename_args_path=arg_path,rename_args_dest=arg_dest})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_rename ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Rename_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (rename_result_ouch res)
  P.return $ rename_result_success res
mkdirs (ip,op) arg_path = do
  send_mkdirs op arg_path
  recv_mkdirs ip
send_mkdirs op arg_path = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("mkdirs", T.M_CALL, seqn)
  write_Mkdirs_args op (Mkdirs_args{mkdirs_args_path=arg_path})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_mkdirs ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Mkdirs_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (mkdirs_result_ouch res)
  P.return $ mkdirs_result_success res
exists (ip,op) arg_path = do
  send_exists op arg_path
  recv_exists ip
send_exists op arg_path = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("exists", T.M_CALL, seqn)
  write_Exists_args op (Exists_args{exists_args_path=arg_path})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_exists ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Exists_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (exists_result_ouch res)
  P.return $ exists_result_success res
stat (ip,op) arg_path = do
  send_stat op arg_path
  recv_stat ip
send_stat op arg_path = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("stat", T.M_CALL, seqn)
  write_Stat_args op (Stat_args{stat_args_path=arg_path})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_stat ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Stat_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (stat_result_ouch res)
  P.return $ stat_result_success res
listStatus (ip,op) arg_path = do
  send_listStatus op arg_path
  recv_listStatus ip
send_listStatus op arg_path = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("listStatus", T.M_CALL, seqn)
  write_ListStatus_args op (ListStatus_args{listStatus_args_path=arg_path})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_listStatus ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_ListStatus_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (listStatus_result_ouch res)
  P.return $ listStatus_result_success res
chmod (ip,op) arg_path arg_mode = do
  send_chmod op arg_path arg_mode
  recv_chmod ip
send_chmod op arg_path arg_mode = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("chmod", T.M_CALL, seqn)
  write_Chmod_args op (Chmod_args{chmod_args_path=arg_path,chmod_args_mode=arg_mode})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_chmod ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Chmod_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (chmod_result_ouch res)
  P.return ()
chown (ip,op) arg_path arg_owner arg_group = do
  send_chown op arg_path arg_owner arg_group
  recv_chown ip
send_chown op arg_path arg_owner arg_group = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("chown", T.M_CALL, seqn)
  write_Chown_args op (Chown_args{chown_args_path=arg_path,chown_args_owner=arg_owner,chown_args_group=arg_group})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_chown ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_Chown_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (chown_result_ouch res)
  P.return ()
setReplication (ip,op) arg_path arg_replication = do
  send_setReplication op arg_path arg_replication
  recv_setReplication ip
send_setReplication op arg_path arg_replication = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("setReplication", T.M_CALL, seqn)
  write_SetReplication_args op (SetReplication_args{setReplication_args_path=arg_path,setReplication_args_replication=arg_replication})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_setReplication ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_SetReplication_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (setReplication_result_ouch res)
  P.return ()
getFileBlockLocations (ip,op) arg_path arg_start arg_length = do
  send_getFileBlockLocations op arg_path arg_start arg_length
  recv_getFileBlockLocations ip
send_getFileBlockLocations op arg_path arg_start arg_length = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessageBegin op ("getFileBlockLocations", T.M_CALL, seqn)
  write_GetFileBlockLocations_args op (GetFileBlockLocations_args{getFileBlockLocations_args_path=arg_path,getFileBlockLocations_args_start=arg_start,getFileBlockLocations_args_length=arg_length})
  T.writeMessageEnd op
  T.tFlush (T.getTransport op)
recv_getFileBlockLocations ip = do
  (fname, mtype, rseqid) <- T.readMessageBegin ip
  M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; T.readMessageEnd ip ; X.throw exn }
  res <- read_GetFileBlockLocations_result ip
  T.readMessageEnd ip
  P.maybe (P.return ()) X.throw (getFileBlockLocations_result_ouch res)
  P.return $ getFileBlockLocations_result_success res
