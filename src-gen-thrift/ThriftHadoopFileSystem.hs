{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.3)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ThriftHadoopFileSystem where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Hadoopfs_Types
import qualified ThriftHadoopFileSystem_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data SetInactivityTimeoutPeriod_args = SetInactivityTimeoutPeriod_args  { setInactivityTimeoutPeriod_args_periodInSeconds :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetInactivityTimeoutPeriod_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setInactivityTimeoutPeriod_args_periodInSeconds record  
instance QC.Arbitrary SetInactivityTimeoutPeriod_args where 
  arbitrary = M.liftM SetInactivityTimeoutPeriod_args (QC.arbitrary)
  shrink obj | obj == default_SetInactivityTimeoutPeriod_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetInactivityTimeoutPeriod_args{setInactivityTimeoutPeriod_args_periodInSeconds = setInactivityTimeoutPeriod_args_periodInSeconds obj} then P.Nothing else P.Just $ default_SetInactivityTimeoutPeriod_args{setInactivityTimeoutPeriod_args_periodInSeconds = setInactivityTimeoutPeriod_args_periodInSeconds obj}
    ]
from_SetInactivityTimeoutPeriod_args :: SetInactivityTimeoutPeriod_args -> T.ThriftVal
from_SetInactivityTimeoutPeriod_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v57 -> P.Just (1, ("periodInSeconds",T.TI64 _v57))) $ setInactivityTimeoutPeriod_args_periodInSeconds record
  ]
write_SetInactivityTimeoutPeriod_args :: (T.Protocol p, T.Transport t) => p t -> SetInactivityTimeoutPeriod_args -> P.IO ()
write_SetInactivityTimeoutPeriod_args oprot record = T.writeVal oprot $ from_SetInactivityTimeoutPeriod_args record
encode_SetInactivityTimeoutPeriod_args :: (T.Protocol p, T.Transport t) => p t -> SetInactivityTimeoutPeriod_args -> LBS.ByteString
encode_SetInactivityTimeoutPeriod_args oprot record = T.serializeVal oprot $ from_SetInactivityTimeoutPeriod_args record
to_SetInactivityTimeoutPeriod_args :: T.ThriftVal -> SetInactivityTimeoutPeriod_args
to_SetInactivityTimeoutPeriod_args (T.TStruct fields) = SetInactivityTimeoutPeriod_args{
  setInactivityTimeoutPeriod_args_periodInSeconds = P.maybe (setInactivityTimeoutPeriod_args_periodInSeconds default_SetInactivityTimeoutPeriod_args) (\(_,_val59) -> (case _val59 of {T.TI64 _val60 -> _val60; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SetInactivityTimeoutPeriod_args _ = P.error "not a struct"
read_SetInactivityTimeoutPeriod_args :: (T.Transport t, T.Protocol p) => p t -> P.IO SetInactivityTimeoutPeriod_args
read_SetInactivityTimeoutPeriod_args iprot = to_SetInactivityTimeoutPeriod_args <$> T.readVal iprot (T.T_STRUCT typemap_SetInactivityTimeoutPeriod_args)
decode_SetInactivityTimeoutPeriod_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SetInactivityTimeoutPeriod_args
decode_SetInactivityTimeoutPeriod_args iprot bs = to_SetInactivityTimeoutPeriod_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetInactivityTimeoutPeriod_args) bs
typemap_SetInactivityTimeoutPeriod_args :: T.TypeMap
typemap_SetInactivityTimeoutPeriod_args = Map.fromList [(1,("periodInSeconds",T.T_I64))]
default_SetInactivityTimeoutPeriod_args :: SetInactivityTimeoutPeriod_args
default_SetInactivityTimeoutPeriod_args = SetInactivityTimeoutPeriod_args{
  setInactivityTimeoutPeriod_args_periodInSeconds = 0}
data SetInactivityTimeoutPeriod_result = SetInactivityTimeoutPeriod_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetInactivityTimeoutPeriod_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary SetInactivityTimeoutPeriod_result where 
  arbitrary = QC.elements [SetInactivityTimeoutPeriod_result]
from_SetInactivityTimeoutPeriod_result :: SetInactivityTimeoutPeriod_result -> T.ThriftVal
from_SetInactivityTimeoutPeriod_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_SetInactivityTimeoutPeriod_result :: (T.Protocol p, T.Transport t) => p t -> SetInactivityTimeoutPeriod_result -> P.IO ()
write_SetInactivityTimeoutPeriod_result oprot record = T.writeVal oprot $ from_SetInactivityTimeoutPeriod_result record
encode_SetInactivityTimeoutPeriod_result :: (T.Protocol p, T.Transport t) => p t -> SetInactivityTimeoutPeriod_result -> LBS.ByteString
encode_SetInactivityTimeoutPeriod_result oprot record = T.serializeVal oprot $ from_SetInactivityTimeoutPeriod_result record
to_SetInactivityTimeoutPeriod_result :: T.ThriftVal -> SetInactivityTimeoutPeriod_result
to_SetInactivityTimeoutPeriod_result (T.TStruct fields) = SetInactivityTimeoutPeriod_result{

  }
to_SetInactivityTimeoutPeriod_result _ = P.error "not a struct"
read_SetInactivityTimeoutPeriod_result :: (T.Transport t, T.Protocol p) => p t -> P.IO SetInactivityTimeoutPeriod_result
read_SetInactivityTimeoutPeriod_result iprot = to_SetInactivityTimeoutPeriod_result <$> T.readVal iprot (T.T_STRUCT typemap_SetInactivityTimeoutPeriod_result)
decode_SetInactivityTimeoutPeriod_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SetInactivityTimeoutPeriod_result
decode_SetInactivityTimeoutPeriod_result iprot bs = to_SetInactivityTimeoutPeriod_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetInactivityTimeoutPeriod_result) bs
typemap_SetInactivityTimeoutPeriod_result :: T.TypeMap
typemap_SetInactivityTimeoutPeriod_result = Map.fromList []
default_SetInactivityTimeoutPeriod_result :: SetInactivityTimeoutPeriod_result
default_SetInactivityTimeoutPeriod_result = SetInactivityTimeoutPeriod_result{
}
data Shutdown_args = Shutdown_args  { shutdown_args_status :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Shutdown_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` shutdown_args_status record  
instance QC.Arbitrary Shutdown_args where 
  arbitrary = M.liftM Shutdown_args (QC.arbitrary)
  shrink obj | obj == default_Shutdown_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Shutdown_args{shutdown_args_status = shutdown_args_status obj} then P.Nothing else P.Just $ default_Shutdown_args{shutdown_args_status = shutdown_args_status obj}
    ]
from_Shutdown_args :: Shutdown_args -> T.ThriftVal
from_Shutdown_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v68 -> P.Just (1, ("status",T.TI32 _v68))) $ shutdown_args_status record
  ]
write_Shutdown_args :: (T.Protocol p, T.Transport t) => p t -> Shutdown_args -> P.IO ()
write_Shutdown_args oprot record = T.writeVal oprot $ from_Shutdown_args record
encode_Shutdown_args :: (T.Protocol p, T.Transport t) => p t -> Shutdown_args -> LBS.ByteString
encode_Shutdown_args oprot record = T.serializeVal oprot $ from_Shutdown_args record
to_Shutdown_args :: T.ThriftVal -> Shutdown_args
to_Shutdown_args (T.TStruct fields) = Shutdown_args{
  shutdown_args_status = P.maybe (shutdown_args_status default_Shutdown_args) (\(_,_val70) -> (case _val70 of {T.TI32 _val71 -> _val71; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Shutdown_args _ = P.error "not a struct"
read_Shutdown_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Shutdown_args
read_Shutdown_args iprot = to_Shutdown_args <$> T.readVal iprot (T.T_STRUCT typemap_Shutdown_args)
decode_Shutdown_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Shutdown_args
decode_Shutdown_args iprot bs = to_Shutdown_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Shutdown_args) bs
typemap_Shutdown_args :: T.TypeMap
typemap_Shutdown_args = Map.fromList [(1,("status",T.T_I32))]
default_Shutdown_args :: Shutdown_args
default_Shutdown_args = Shutdown_args{
  shutdown_args_status = 0}
data Shutdown_result = Shutdown_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Shutdown_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Shutdown_result where 
  arbitrary = QC.elements [Shutdown_result]
from_Shutdown_result :: Shutdown_result -> T.ThriftVal
from_Shutdown_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Shutdown_result :: (T.Protocol p, T.Transport t) => p t -> Shutdown_result -> P.IO ()
write_Shutdown_result oprot record = T.writeVal oprot $ from_Shutdown_result record
encode_Shutdown_result :: (T.Protocol p, T.Transport t) => p t -> Shutdown_result -> LBS.ByteString
encode_Shutdown_result oprot record = T.serializeVal oprot $ from_Shutdown_result record
to_Shutdown_result :: T.ThriftVal -> Shutdown_result
to_Shutdown_result (T.TStruct fields) = Shutdown_result{

  }
to_Shutdown_result _ = P.error "not a struct"
read_Shutdown_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Shutdown_result
read_Shutdown_result iprot = to_Shutdown_result <$> T.readVal iprot (T.T_STRUCT typemap_Shutdown_result)
decode_Shutdown_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Shutdown_result
decode_Shutdown_result iprot bs = to_Shutdown_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Shutdown_result) bs
typemap_Shutdown_result :: T.TypeMap
typemap_Shutdown_result = Map.fromList []
default_Shutdown_result :: Shutdown_result
default_Shutdown_result = Shutdown_result{
}
data Create_args = Create_args  { create_args_path :: Pathname
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Create_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` create_args_path record  
instance QC.Arbitrary Create_args where 
  arbitrary = M.liftM Create_args (QC.arbitrary)
  shrink obj | obj == default_Create_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Create_args{create_args_path = create_args_path obj} then P.Nothing else P.Just $ default_Create_args{create_args_path = create_args_path obj}
    ]
from_Create_args :: Create_args -> T.ThriftVal
from_Create_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v79 -> P.Just (1, ("path",from_Pathname _v79))) $ create_args_path record
  ]
write_Create_args :: (T.Protocol p, T.Transport t) => p t -> Create_args -> P.IO ()
write_Create_args oprot record = T.writeVal oprot $ from_Create_args record
encode_Create_args :: (T.Protocol p, T.Transport t) => p t -> Create_args -> LBS.ByteString
encode_Create_args oprot record = T.serializeVal oprot $ from_Create_args record
to_Create_args :: T.ThriftVal -> Create_args
to_Create_args (T.TStruct fields) = Create_args{
  create_args_path = P.maybe (create_args_path default_Create_args) (\(_,_val81) -> (case _val81 of {T.TStruct _val82 -> (to_Pathname (T.TStruct _val82)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Create_args _ = P.error "not a struct"
read_Create_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Create_args
read_Create_args iprot = to_Create_args <$> T.readVal iprot (T.T_STRUCT typemap_Create_args)
decode_Create_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Create_args
decode_Create_args iprot bs = to_Create_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Create_args) bs
typemap_Create_args :: T.TypeMap
typemap_Create_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname)))]
default_Create_args :: Create_args
default_Create_args = Create_args{
  create_args_path = default_Pathname}
data Create_result = Create_result  { create_result_success :: ThriftHandle
  , create_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Create_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` create_result_success record   `H.hashWithSalt` create_result_ouch record  
instance QC.Arbitrary Create_result where 
  arbitrary = M.liftM Create_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Create_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Create_result{create_result_success = create_result_success obj} then P.Nothing else P.Just $ default_Create_result{create_result_success = create_result_success obj}
    , if obj == default_Create_result{create_result_ouch = create_result_ouch obj} then P.Nothing else P.Just $ default_Create_result{create_result_ouch = create_result_ouch obj}
    ]
from_Create_result :: Create_result -> T.ThriftVal
from_Create_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v85 -> (1, ("ouch",from_ThriftIOException _v85))) <$> create_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v85 -> P.Just (0, ("success",from_ThriftHandle _v85))) $ create_result_success record
    , (\_v85 -> (1, ("ouch",from_ThriftIOException _v85))) <$> create_result_ouch record
    ]
    )
write_Create_result :: (T.Protocol p, T.Transport t) => p t -> Create_result -> P.IO ()
write_Create_result oprot record = T.writeVal oprot $ from_Create_result record
encode_Create_result :: (T.Protocol p, T.Transport t) => p t -> Create_result -> LBS.ByteString
encode_Create_result oprot record = T.serializeVal oprot $ from_Create_result record
to_Create_result :: T.ThriftVal -> Create_result
to_Create_result (T.TStruct fields) = Create_result{
  create_result_success = P.maybe (create_result_success default_Create_result) (\(_,_val87) -> (case _val87 of {T.TStruct _val88 -> (to_ThriftHandle (T.TStruct _val88)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  create_result_ouch = P.maybe (P.Nothing) (\(_,_val87) -> P.Just (case _val87 of {T.TStruct _val89 -> (to_ThriftIOException (T.TStruct _val89)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Create_result _ = P.error "not a struct"
read_Create_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Create_result
read_Create_result iprot = to_Create_result <$> T.readVal iprot (T.T_STRUCT typemap_Create_result)
decode_Create_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Create_result
decode_Create_result iprot bs = to_Create_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Create_result) bs
typemap_Create_result :: T.TypeMap
typemap_Create_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ThriftHandle))),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Create_result :: Create_result
default_Create_result = Create_result{
  create_result_success = default_ThriftHandle,
  create_result_ouch = P.Nothing}
data CreateFile_args = CreateFile_args  { createFile_args_path :: Pathname
  , createFile_args_mode :: I.Int16
  , createFile_args_overwrite :: P.Bool
  , createFile_args_bufferSize :: I.Int32
  , createFile_args_block_replication :: I.Int16
  , createFile_args_blocksize :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateFile_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createFile_args_path record   `H.hashWithSalt` createFile_args_mode record   `H.hashWithSalt` createFile_args_overwrite record   `H.hashWithSalt` createFile_args_bufferSize record   `H.hashWithSalt` createFile_args_block_replication record   `H.hashWithSalt` createFile_args_blocksize record  
instance QC.Arbitrary CreateFile_args where 
  arbitrary = M.liftM CreateFile_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateFile_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateFile_args{createFile_args_path = createFile_args_path obj} then P.Nothing else P.Just $ default_CreateFile_args{createFile_args_path = createFile_args_path obj}
    , if obj == default_CreateFile_args{createFile_args_mode = createFile_args_mode obj} then P.Nothing else P.Just $ default_CreateFile_args{createFile_args_mode = createFile_args_mode obj}
    , if obj == default_CreateFile_args{createFile_args_overwrite = createFile_args_overwrite obj} then P.Nothing else P.Just $ default_CreateFile_args{createFile_args_overwrite = createFile_args_overwrite obj}
    , if obj == default_CreateFile_args{createFile_args_bufferSize = createFile_args_bufferSize obj} then P.Nothing else P.Just $ default_CreateFile_args{createFile_args_bufferSize = createFile_args_bufferSize obj}
    , if obj == default_CreateFile_args{createFile_args_block_replication = createFile_args_block_replication obj} then P.Nothing else P.Just $ default_CreateFile_args{createFile_args_block_replication = createFile_args_block_replication obj}
    , if obj == default_CreateFile_args{createFile_args_blocksize = createFile_args_blocksize obj} then P.Nothing else P.Just $ default_CreateFile_args{createFile_args_blocksize = createFile_args_blocksize obj}
    ]
from_CreateFile_args :: CreateFile_args -> T.ThriftVal
from_CreateFile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v92 -> P.Just (1, ("path",from_Pathname _v92))) $ createFile_args_path record
  , (\_v92 -> P.Just (2, ("mode",T.TI16 _v92))) $ createFile_args_mode record
  , (\_v92 -> P.Just (3, ("overwrite",T.TBool _v92))) $ createFile_args_overwrite record
  , (\_v92 -> P.Just (4, ("bufferSize",T.TI32 _v92))) $ createFile_args_bufferSize record
  , (\_v92 -> P.Just (5, ("block_replication",T.TI16 _v92))) $ createFile_args_block_replication record
  , (\_v92 -> P.Just (6, ("blocksize",T.TI64 _v92))) $ createFile_args_blocksize record
  ]
write_CreateFile_args :: (T.Protocol p, T.Transport t) => p t -> CreateFile_args -> P.IO ()
write_CreateFile_args oprot record = T.writeVal oprot $ from_CreateFile_args record
encode_CreateFile_args :: (T.Protocol p, T.Transport t) => p t -> CreateFile_args -> LBS.ByteString
encode_CreateFile_args oprot record = T.serializeVal oprot $ from_CreateFile_args record
to_CreateFile_args :: T.ThriftVal -> CreateFile_args
to_CreateFile_args (T.TStruct fields) = CreateFile_args{
  createFile_args_path = P.maybe (createFile_args_path default_CreateFile_args) (\(_,_val94) -> (case _val94 of {T.TStruct _val95 -> (to_Pathname (T.TStruct _val95)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createFile_args_mode = P.maybe (createFile_args_mode default_CreateFile_args) (\(_,_val94) -> (case _val94 of {T.TI16 _val96 -> _val96; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createFile_args_overwrite = P.maybe (createFile_args_overwrite default_CreateFile_args) (\(_,_val94) -> (case _val94 of {T.TBool _val97 -> _val97; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  createFile_args_bufferSize = P.maybe (createFile_args_bufferSize default_CreateFile_args) (\(_,_val94) -> (case _val94 of {T.TI32 _val98 -> _val98; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  createFile_args_block_replication = P.maybe (createFile_args_block_replication default_CreateFile_args) (\(_,_val94) -> (case _val94 of {T.TI16 _val99 -> _val99; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  createFile_args_blocksize = P.maybe (createFile_args_blocksize default_CreateFile_args) (\(_,_val94) -> (case _val94 of {T.TI64 _val100 -> _val100; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_CreateFile_args _ = P.error "not a struct"
read_CreateFile_args :: (T.Transport t, T.Protocol p) => p t -> P.IO CreateFile_args
read_CreateFile_args iprot = to_CreateFile_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateFile_args)
decode_CreateFile_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CreateFile_args
decode_CreateFile_args iprot bs = to_CreateFile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateFile_args) bs
typemap_CreateFile_args :: T.TypeMap
typemap_CreateFile_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname))),(2,("mode",T.T_I16)),(3,("overwrite",T.T_BOOL)),(4,("bufferSize",T.T_I32)),(5,("block_replication",T.T_I16)),(6,("blocksize",T.T_I64))]
default_CreateFile_args :: CreateFile_args
default_CreateFile_args = CreateFile_args{
  createFile_args_path = default_Pathname,
  createFile_args_mode = 0,
  createFile_args_overwrite = P.False,
  createFile_args_bufferSize = 0,
  createFile_args_block_replication = 0,
  createFile_args_blocksize = 0}
data CreateFile_result = CreateFile_result  { createFile_result_success :: ThriftHandle
  , createFile_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateFile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createFile_result_success record   `H.hashWithSalt` createFile_result_ouch record  
instance QC.Arbitrary CreateFile_result where 
  arbitrary = M.liftM CreateFile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateFile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateFile_result{createFile_result_success = createFile_result_success obj} then P.Nothing else P.Just $ default_CreateFile_result{createFile_result_success = createFile_result_success obj}
    , if obj == default_CreateFile_result{createFile_result_ouch = createFile_result_ouch obj} then P.Nothing else P.Just $ default_CreateFile_result{createFile_result_ouch = createFile_result_ouch obj}
    ]
from_CreateFile_result :: CreateFile_result -> T.ThriftVal
from_CreateFile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v103 -> (1, ("ouch",from_ThriftIOException _v103))) <$> createFile_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v103 -> P.Just (0, ("success",from_ThriftHandle _v103))) $ createFile_result_success record
    , (\_v103 -> (1, ("ouch",from_ThriftIOException _v103))) <$> createFile_result_ouch record
    ]
    )
write_CreateFile_result :: (T.Protocol p, T.Transport t) => p t -> CreateFile_result -> P.IO ()
write_CreateFile_result oprot record = T.writeVal oprot $ from_CreateFile_result record
encode_CreateFile_result :: (T.Protocol p, T.Transport t) => p t -> CreateFile_result -> LBS.ByteString
encode_CreateFile_result oprot record = T.serializeVal oprot $ from_CreateFile_result record
to_CreateFile_result :: T.ThriftVal -> CreateFile_result
to_CreateFile_result (T.TStruct fields) = CreateFile_result{
  createFile_result_success = P.maybe (createFile_result_success default_CreateFile_result) (\(_,_val105) -> (case _val105 of {T.TStruct _val106 -> (to_ThriftHandle (T.TStruct _val106)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createFile_result_ouch = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TStruct _val107 -> (to_ThriftIOException (T.TStruct _val107)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateFile_result _ = P.error "not a struct"
read_CreateFile_result :: (T.Transport t, T.Protocol p) => p t -> P.IO CreateFile_result
read_CreateFile_result iprot = to_CreateFile_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateFile_result)
decode_CreateFile_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> CreateFile_result
decode_CreateFile_result iprot bs = to_CreateFile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateFile_result) bs
typemap_CreateFile_result :: T.TypeMap
typemap_CreateFile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ThriftHandle))),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_CreateFile_result :: CreateFile_result
default_CreateFile_result = CreateFile_result{
  createFile_result_success = default_ThriftHandle,
  createFile_result_ouch = P.Nothing}
data Open_args = Open_args  { open_args_path :: Pathname
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Open_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` open_args_path record  
instance QC.Arbitrary Open_args where 
  arbitrary = M.liftM Open_args (QC.arbitrary)
  shrink obj | obj == default_Open_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Open_args{open_args_path = open_args_path obj} then P.Nothing else P.Just $ default_Open_args{open_args_path = open_args_path obj}
    ]
from_Open_args :: Open_args -> T.ThriftVal
from_Open_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v110 -> P.Just (1, ("path",from_Pathname _v110))) $ open_args_path record
  ]
write_Open_args :: (T.Protocol p, T.Transport t) => p t -> Open_args -> P.IO ()
write_Open_args oprot record = T.writeVal oprot $ from_Open_args record
encode_Open_args :: (T.Protocol p, T.Transport t) => p t -> Open_args -> LBS.ByteString
encode_Open_args oprot record = T.serializeVal oprot $ from_Open_args record
to_Open_args :: T.ThriftVal -> Open_args
to_Open_args (T.TStruct fields) = Open_args{
  open_args_path = P.maybe (open_args_path default_Open_args) (\(_,_val112) -> (case _val112 of {T.TStruct _val113 -> (to_Pathname (T.TStruct _val113)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Open_args _ = P.error "not a struct"
read_Open_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Open_args
read_Open_args iprot = to_Open_args <$> T.readVal iprot (T.T_STRUCT typemap_Open_args)
decode_Open_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Open_args
decode_Open_args iprot bs = to_Open_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Open_args) bs
typemap_Open_args :: T.TypeMap
typemap_Open_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname)))]
default_Open_args :: Open_args
default_Open_args = Open_args{
  open_args_path = default_Pathname}
data Open_result = Open_result  { open_result_success :: ThriftHandle
  , open_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Open_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` open_result_success record   `H.hashWithSalt` open_result_ouch record  
instance QC.Arbitrary Open_result where 
  arbitrary = M.liftM Open_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Open_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Open_result{open_result_success = open_result_success obj} then P.Nothing else P.Just $ default_Open_result{open_result_success = open_result_success obj}
    , if obj == default_Open_result{open_result_ouch = open_result_ouch obj} then P.Nothing else P.Just $ default_Open_result{open_result_ouch = open_result_ouch obj}
    ]
from_Open_result :: Open_result -> T.ThriftVal
from_Open_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v116 -> (1, ("ouch",from_ThriftIOException _v116))) <$> open_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v116 -> P.Just (0, ("success",from_ThriftHandle _v116))) $ open_result_success record
    , (\_v116 -> (1, ("ouch",from_ThriftIOException _v116))) <$> open_result_ouch record
    ]
    )
write_Open_result :: (T.Protocol p, T.Transport t) => p t -> Open_result -> P.IO ()
write_Open_result oprot record = T.writeVal oprot $ from_Open_result record
encode_Open_result :: (T.Protocol p, T.Transport t) => p t -> Open_result -> LBS.ByteString
encode_Open_result oprot record = T.serializeVal oprot $ from_Open_result record
to_Open_result :: T.ThriftVal -> Open_result
to_Open_result (T.TStruct fields) = Open_result{
  open_result_success = P.maybe (open_result_success default_Open_result) (\(_,_val118) -> (case _val118 of {T.TStruct _val119 -> (to_ThriftHandle (T.TStruct _val119)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  open_result_ouch = P.maybe (P.Nothing) (\(_,_val118) -> P.Just (case _val118 of {T.TStruct _val120 -> (to_ThriftIOException (T.TStruct _val120)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Open_result _ = P.error "not a struct"
read_Open_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Open_result
read_Open_result iprot = to_Open_result <$> T.readVal iprot (T.T_STRUCT typemap_Open_result)
decode_Open_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Open_result
decode_Open_result iprot bs = to_Open_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Open_result) bs
typemap_Open_result :: T.TypeMap
typemap_Open_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ThriftHandle))),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Open_result :: Open_result
default_Open_result = Open_result{
  open_result_success = default_ThriftHandle,
  open_result_ouch = P.Nothing}
data Append_args = Append_args  { append_args_path :: Pathname
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Append_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` append_args_path record  
instance QC.Arbitrary Append_args where 
  arbitrary = M.liftM Append_args (QC.arbitrary)
  shrink obj | obj == default_Append_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Append_args{append_args_path = append_args_path obj} then P.Nothing else P.Just $ default_Append_args{append_args_path = append_args_path obj}
    ]
from_Append_args :: Append_args -> T.ThriftVal
from_Append_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v123 -> P.Just (1, ("path",from_Pathname _v123))) $ append_args_path record
  ]
write_Append_args :: (T.Protocol p, T.Transport t) => p t -> Append_args -> P.IO ()
write_Append_args oprot record = T.writeVal oprot $ from_Append_args record
encode_Append_args :: (T.Protocol p, T.Transport t) => p t -> Append_args -> LBS.ByteString
encode_Append_args oprot record = T.serializeVal oprot $ from_Append_args record
to_Append_args :: T.ThriftVal -> Append_args
to_Append_args (T.TStruct fields) = Append_args{
  append_args_path = P.maybe (append_args_path default_Append_args) (\(_,_val125) -> (case _val125 of {T.TStruct _val126 -> (to_Pathname (T.TStruct _val126)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Append_args _ = P.error "not a struct"
read_Append_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Append_args
read_Append_args iprot = to_Append_args <$> T.readVal iprot (T.T_STRUCT typemap_Append_args)
decode_Append_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Append_args
decode_Append_args iprot bs = to_Append_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Append_args) bs
typemap_Append_args :: T.TypeMap
typemap_Append_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname)))]
default_Append_args :: Append_args
default_Append_args = Append_args{
  append_args_path = default_Pathname}
data Append_result = Append_result  { append_result_success :: ThriftHandle
  , append_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Append_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` append_result_success record   `H.hashWithSalt` append_result_ouch record  
instance QC.Arbitrary Append_result where 
  arbitrary = M.liftM Append_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Append_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Append_result{append_result_success = append_result_success obj} then P.Nothing else P.Just $ default_Append_result{append_result_success = append_result_success obj}
    , if obj == default_Append_result{append_result_ouch = append_result_ouch obj} then P.Nothing else P.Just $ default_Append_result{append_result_ouch = append_result_ouch obj}
    ]
from_Append_result :: Append_result -> T.ThriftVal
from_Append_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v129 -> (1, ("ouch",from_ThriftIOException _v129))) <$> append_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v129 -> P.Just (0, ("success",from_ThriftHandle _v129))) $ append_result_success record
    , (\_v129 -> (1, ("ouch",from_ThriftIOException _v129))) <$> append_result_ouch record
    ]
    )
write_Append_result :: (T.Protocol p, T.Transport t) => p t -> Append_result -> P.IO ()
write_Append_result oprot record = T.writeVal oprot $ from_Append_result record
encode_Append_result :: (T.Protocol p, T.Transport t) => p t -> Append_result -> LBS.ByteString
encode_Append_result oprot record = T.serializeVal oprot $ from_Append_result record
to_Append_result :: T.ThriftVal -> Append_result
to_Append_result (T.TStruct fields) = Append_result{
  append_result_success = P.maybe (append_result_success default_Append_result) (\(_,_val131) -> (case _val131 of {T.TStruct _val132 -> (to_ThriftHandle (T.TStruct _val132)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  append_result_ouch = P.maybe (P.Nothing) (\(_,_val131) -> P.Just (case _val131 of {T.TStruct _val133 -> (to_ThriftIOException (T.TStruct _val133)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Append_result _ = P.error "not a struct"
read_Append_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Append_result
read_Append_result iprot = to_Append_result <$> T.readVal iprot (T.T_STRUCT typemap_Append_result)
decode_Append_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Append_result
decode_Append_result iprot bs = to_Append_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Append_result) bs
typemap_Append_result :: T.TypeMap
typemap_Append_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ThriftHandle))),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Append_result :: Append_result
default_Append_result = Append_result{
  append_result_success = default_ThriftHandle,
  append_result_ouch = P.Nothing}
data Write_args = Write_args  { write_args_handle :: ThriftHandle
  , write_args_data :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Write_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` write_args_handle record   `H.hashWithSalt` write_args_data record  
instance QC.Arbitrary Write_args where 
  arbitrary = M.liftM Write_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Write_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Write_args{write_args_handle = write_args_handle obj} then P.Nothing else P.Just $ default_Write_args{write_args_handle = write_args_handle obj}
    , if obj == default_Write_args{write_args_data = write_args_data obj} then P.Nothing else P.Just $ default_Write_args{write_args_data = write_args_data obj}
    ]
from_Write_args :: Write_args -> T.ThriftVal
from_Write_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v136 -> P.Just (-1, ("data",T.TString $ E.encodeUtf8 _v136))) $ write_args_data record
  , (\_v136 -> P.Just (1, ("handle",from_ThriftHandle _v136))) $ write_args_handle record
  ]
write_Write_args :: (T.Protocol p, T.Transport t) => p t -> Write_args -> P.IO ()
write_Write_args oprot record = T.writeVal oprot $ from_Write_args record
encode_Write_args :: (T.Protocol p, T.Transport t) => p t -> Write_args -> LBS.ByteString
encode_Write_args oprot record = T.serializeVal oprot $ from_Write_args record
to_Write_args :: T.ThriftVal -> Write_args
to_Write_args (T.TStruct fields) = Write_args{
  write_args_handle = P.maybe (write_args_handle default_Write_args) (\(_,_val138) -> (case _val138 of {T.TStruct _val139 -> (to_ThriftHandle (T.TStruct _val139)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  write_args_data = P.maybe (write_args_data default_Write_args) (\(_,_val138) -> (case _val138 of {T.TString _val140 -> E.decodeUtf8 _val140; _ -> P.error "wrong type"})) (Map.lookup (-1) fields)
  }
to_Write_args _ = P.error "not a struct"
read_Write_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Write_args
read_Write_args iprot = to_Write_args <$> T.readVal iprot (T.T_STRUCT typemap_Write_args)
decode_Write_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Write_args
decode_Write_args iprot bs = to_Write_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Write_args) bs
typemap_Write_args :: T.TypeMap
typemap_Write_args = Map.fromList [(-1,("data",T.T_STRING)),(1,("handle",(T.T_STRUCT typemap_ThriftHandle)))]
default_Write_args :: Write_args
default_Write_args = Write_args{
  write_args_data = "",
  write_args_handle = default_ThriftHandle}
data Write_result = Write_result  { write_result_success :: P.Bool
  , write_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Write_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` write_result_success record   `H.hashWithSalt` write_result_ouch record  
instance QC.Arbitrary Write_result where 
  arbitrary = M.liftM Write_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Write_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Write_result{write_result_success = write_result_success obj} then P.Nothing else P.Just $ default_Write_result{write_result_success = write_result_success obj}
    , if obj == default_Write_result{write_result_ouch = write_result_ouch obj} then P.Nothing else P.Just $ default_Write_result{write_result_ouch = write_result_ouch obj}
    ]
from_Write_result :: Write_result -> T.ThriftVal
from_Write_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v143 -> (1, ("ouch",from_ThriftIOException _v143))) <$> write_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v143 -> P.Just (0, ("success",T.TBool _v143))) $ write_result_success record
    , (\_v143 -> (1, ("ouch",from_ThriftIOException _v143))) <$> write_result_ouch record
    ]
    )
write_Write_result :: (T.Protocol p, T.Transport t) => p t -> Write_result -> P.IO ()
write_Write_result oprot record = T.writeVal oprot $ from_Write_result record
encode_Write_result :: (T.Protocol p, T.Transport t) => p t -> Write_result -> LBS.ByteString
encode_Write_result oprot record = T.serializeVal oprot $ from_Write_result record
to_Write_result :: T.ThriftVal -> Write_result
to_Write_result (T.TStruct fields) = Write_result{
  write_result_success = P.maybe (write_result_success default_Write_result) (\(_,_val145) -> (case _val145 of {T.TBool _val146 -> _val146; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  write_result_ouch = P.maybe (P.Nothing) (\(_,_val145) -> P.Just (case _val145 of {T.TStruct _val147 -> (to_ThriftIOException (T.TStruct _val147)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Write_result _ = P.error "not a struct"
read_Write_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Write_result
read_Write_result iprot = to_Write_result <$> T.readVal iprot (T.T_STRUCT typemap_Write_result)
decode_Write_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Write_result
decode_Write_result iprot bs = to_Write_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Write_result) bs
typemap_Write_result :: T.TypeMap
typemap_Write_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Write_result :: Write_result
default_Write_result = Write_result{
  write_result_success = P.False,
  write_result_ouch = P.Nothing}
data Read_args = Read_args  { read_args_handle :: ThriftHandle
  , read_args_offset :: I.Int64
  , read_args_size :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Read_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` read_args_handle record   `H.hashWithSalt` read_args_offset record   `H.hashWithSalt` read_args_size record  
instance QC.Arbitrary Read_args where 
  arbitrary = M.liftM Read_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Read_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Read_args{read_args_handle = read_args_handle obj} then P.Nothing else P.Just $ default_Read_args{read_args_handle = read_args_handle obj}
    , if obj == default_Read_args{read_args_offset = read_args_offset obj} then P.Nothing else P.Just $ default_Read_args{read_args_offset = read_args_offset obj}
    , if obj == default_Read_args{read_args_size = read_args_size obj} then P.Nothing else P.Just $ default_Read_args{read_args_size = read_args_size obj}
    ]
from_Read_args :: Read_args -> T.ThriftVal
from_Read_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v150 -> P.Just (-2, ("size",T.TI32 _v150))) $ read_args_size record
  , (\_v150 -> P.Just (-1, ("offset",T.TI64 _v150))) $ read_args_offset record
  , (\_v150 -> P.Just (1, ("handle",from_ThriftHandle _v150))) $ read_args_handle record
  ]
write_Read_args :: (T.Protocol p, T.Transport t) => p t -> Read_args -> P.IO ()
write_Read_args oprot record = T.writeVal oprot $ from_Read_args record
encode_Read_args :: (T.Protocol p, T.Transport t) => p t -> Read_args -> LBS.ByteString
encode_Read_args oprot record = T.serializeVal oprot $ from_Read_args record
to_Read_args :: T.ThriftVal -> Read_args
to_Read_args (T.TStruct fields) = Read_args{
  read_args_handle = P.maybe (read_args_handle default_Read_args) (\(_,_val152) -> (case _val152 of {T.TStruct _val153 -> (to_ThriftHandle (T.TStruct _val153)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  read_args_offset = P.maybe (read_args_offset default_Read_args) (\(_,_val152) -> (case _val152 of {T.TI64 _val154 -> _val154; _ -> P.error "wrong type"})) (Map.lookup (-1) fields),
  read_args_size = P.maybe (read_args_size default_Read_args) (\(_,_val152) -> (case _val152 of {T.TI32 _val155 -> _val155; _ -> P.error "wrong type"})) (Map.lookup (-2) fields)
  }
to_Read_args _ = P.error "not a struct"
read_Read_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Read_args
read_Read_args iprot = to_Read_args <$> T.readVal iprot (T.T_STRUCT typemap_Read_args)
decode_Read_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Read_args
decode_Read_args iprot bs = to_Read_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Read_args) bs
typemap_Read_args :: T.TypeMap
typemap_Read_args = Map.fromList [(-2,("size",T.T_I32)),(-1,("offset",T.T_I64)),(1,("handle",(T.T_STRUCT typemap_ThriftHandle)))]
default_Read_args :: Read_args
default_Read_args = Read_args{
  read_args_size = 0,
  read_args_offset = 0,
  read_args_handle = default_ThriftHandle}
data Read_result = Read_result  { read_result_success :: LT.Text
  , read_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Read_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` read_result_success record   `H.hashWithSalt` read_result_ouch record  
instance QC.Arbitrary Read_result where 
  arbitrary = M.liftM Read_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Read_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Read_result{read_result_success = read_result_success obj} then P.Nothing else P.Just $ default_Read_result{read_result_success = read_result_success obj}
    , if obj == default_Read_result{read_result_ouch = read_result_ouch obj} then P.Nothing else P.Just $ default_Read_result{read_result_ouch = read_result_ouch obj}
    ]
from_Read_result :: Read_result -> T.ThriftVal
from_Read_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v158 -> (1, ("ouch",from_ThriftIOException _v158))) <$> read_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v158 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v158))) $ read_result_success record
    , (\_v158 -> (1, ("ouch",from_ThriftIOException _v158))) <$> read_result_ouch record
    ]
    )
write_Read_result :: (T.Protocol p, T.Transport t) => p t -> Read_result -> P.IO ()
write_Read_result oprot record = T.writeVal oprot $ from_Read_result record
encode_Read_result :: (T.Protocol p, T.Transport t) => p t -> Read_result -> LBS.ByteString
encode_Read_result oprot record = T.serializeVal oprot $ from_Read_result record
to_Read_result :: T.ThriftVal -> Read_result
to_Read_result (T.TStruct fields) = Read_result{
  read_result_success = P.maybe (read_result_success default_Read_result) (\(_,_val160) -> (case _val160 of {T.TString _val161 -> E.decodeUtf8 _val161; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  read_result_ouch = P.maybe (P.Nothing) (\(_,_val160) -> P.Just (case _val160 of {T.TStruct _val162 -> (to_ThriftIOException (T.TStruct _val162)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Read_result _ = P.error "not a struct"
read_Read_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Read_result
read_Read_result iprot = to_Read_result <$> T.readVal iprot (T.T_STRUCT typemap_Read_result)
decode_Read_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Read_result
decode_Read_result iprot bs = to_Read_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Read_result) bs
typemap_Read_result :: T.TypeMap
typemap_Read_result = Map.fromList [(0,("success",T.T_STRING)),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Read_result :: Read_result
default_Read_result = Read_result{
  read_result_success = "",
  read_result_ouch = P.Nothing}
data Close_args = Close_args  { close_args_out :: ThriftHandle
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Close_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` close_args_out record  
instance QC.Arbitrary Close_args where 
  arbitrary = M.liftM Close_args (QC.arbitrary)
  shrink obj | obj == default_Close_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Close_args{close_args_out = close_args_out obj} then P.Nothing else P.Just $ default_Close_args{close_args_out = close_args_out obj}
    ]
from_Close_args :: Close_args -> T.ThriftVal
from_Close_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v165 -> P.Just (1, ("out",from_ThriftHandle _v165))) $ close_args_out record
  ]
write_Close_args :: (T.Protocol p, T.Transport t) => p t -> Close_args -> P.IO ()
write_Close_args oprot record = T.writeVal oprot $ from_Close_args record
encode_Close_args :: (T.Protocol p, T.Transport t) => p t -> Close_args -> LBS.ByteString
encode_Close_args oprot record = T.serializeVal oprot $ from_Close_args record
to_Close_args :: T.ThriftVal -> Close_args
to_Close_args (T.TStruct fields) = Close_args{
  close_args_out = P.maybe (close_args_out default_Close_args) (\(_,_val167) -> (case _val167 of {T.TStruct _val168 -> (to_ThriftHandle (T.TStruct _val168)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Close_args _ = P.error "not a struct"
read_Close_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Close_args
read_Close_args iprot = to_Close_args <$> T.readVal iprot (T.T_STRUCT typemap_Close_args)
decode_Close_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Close_args
decode_Close_args iprot bs = to_Close_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Close_args) bs
typemap_Close_args :: T.TypeMap
typemap_Close_args = Map.fromList [(1,("out",(T.T_STRUCT typemap_ThriftHandle)))]
default_Close_args :: Close_args
default_Close_args = Close_args{
  close_args_out = default_ThriftHandle}
data Close_result = Close_result  { close_result_success :: P.Bool
  , close_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Close_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` close_result_success record   `H.hashWithSalt` close_result_ouch record  
instance QC.Arbitrary Close_result where 
  arbitrary = M.liftM Close_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Close_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Close_result{close_result_success = close_result_success obj} then P.Nothing else P.Just $ default_Close_result{close_result_success = close_result_success obj}
    , if obj == default_Close_result{close_result_ouch = close_result_ouch obj} then P.Nothing else P.Just $ default_Close_result{close_result_ouch = close_result_ouch obj}
    ]
from_Close_result :: Close_result -> T.ThriftVal
from_Close_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v171 -> (1, ("ouch",from_ThriftIOException _v171))) <$> close_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v171 -> P.Just (0, ("success",T.TBool _v171))) $ close_result_success record
    , (\_v171 -> (1, ("ouch",from_ThriftIOException _v171))) <$> close_result_ouch record
    ]
    )
write_Close_result :: (T.Protocol p, T.Transport t) => p t -> Close_result -> P.IO ()
write_Close_result oprot record = T.writeVal oprot $ from_Close_result record
encode_Close_result :: (T.Protocol p, T.Transport t) => p t -> Close_result -> LBS.ByteString
encode_Close_result oprot record = T.serializeVal oprot $ from_Close_result record
to_Close_result :: T.ThriftVal -> Close_result
to_Close_result (T.TStruct fields) = Close_result{
  close_result_success = P.maybe (close_result_success default_Close_result) (\(_,_val173) -> (case _val173 of {T.TBool _val174 -> _val174; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  close_result_ouch = P.maybe (P.Nothing) (\(_,_val173) -> P.Just (case _val173 of {T.TStruct _val175 -> (to_ThriftIOException (T.TStruct _val175)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Close_result _ = P.error "not a struct"
read_Close_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Close_result
read_Close_result iprot = to_Close_result <$> T.readVal iprot (T.T_STRUCT typemap_Close_result)
decode_Close_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Close_result
decode_Close_result iprot bs = to_Close_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Close_result) bs
typemap_Close_result :: T.TypeMap
typemap_Close_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Close_result :: Close_result
default_Close_result = Close_result{
  close_result_success = P.False,
  close_result_ouch = P.Nothing}
data Rm_args = Rm_args  { rm_args_path :: Pathname
  , rm_args_recursive :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Rm_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` rm_args_path record   `H.hashWithSalt` rm_args_recursive record  
instance QC.Arbitrary Rm_args where 
  arbitrary = M.liftM Rm_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Rm_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Rm_args{rm_args_path = rm_args_path obj} then P.Nothing else P.Just $ default_Rm_args{rm_args_path = rm_args_path obj}
    , if obj == default_Rm_args{rm_args_recursive = rm_args_recursive obj} then P.Nothing else P.Just $ default_Rm_args{rm_args_recursive = rm_args_recursive obj}
    ]
from_Rm_args :: Rm_args -> T.ThriftVal
from_Rm_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v178 -> P.Just (1, ("path",from_Pathname _v178))) $ rm_args_path record
  , (\_v178 -> P.Just (2, ("recursive",T.TBool _v178))) $ rm_args_recursive record
  ]
write_Rm_args :: (T.Protocol p, T.Transport t) => p t -> Rm_args -> P.IO ()
write_Rm_args oprot record = T.writeVal oprot $ from_Rm_args record
encode_Rm_args :: (T.Protocol p, T.Transport t) => p t -> Rm_args -> LBS.ByteString
encode_Rm_args oprot record = T.serializeVal oprot $ from_Rm_args record
to_Rm_args :: T.ThriftVal -> Rm_args
to_Rm_args (T.TStruct fields) = Rm_args{
  rm_args_path = P.maybe (rm_args_path default_Rm_args) (\(_,_val180) -> (case _val180 of {T.TStruct _val181 -> (to_Pathname (T.TStruct _val181)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  rm_args_recursive = P.maybe (rm_args_recursive default_Rm_args) (\(_,_val180) -> (case _val180 of {T.TBool _val182 -> _val182; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Rm_args _ = P.error "not a struct"
read_Rm_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Rm_args
read_Rm_args iprot = to_Rm_args <$> T.readVal iprot (T.T_STRUCT typemap_Rm_args)
decode_Rm_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Rm_args
decode_Rm_args iprot bs = to_Rm_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Rm_args) bs
typemap_Rm_args :: T.TypeMap
typemap_Rm_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname))),(2,("recursive",T.T_BOOL))]
default_Rm_args :: Rm_args
default_Rm_args = Rm_args{
  rm_args_path = default_Pathname,
  rm_args_recursive = P.False}
data Rm_result = Rm_result  { rm_result_success :: P.Bool
  , rm_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Rm_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` rm_result_success record   `H.hashWithSalt` rm_result_ouch record  
instance QC.Arbitrary Rm_result where 
  arbitrary = M.liftM Rm_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Rm_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Rm_result{rm_result_success = rm_result_success obj} then P.Nothing else P.Just $ default_Rm_result{rm_result_success = rm_result_success obj}
    , if obj == default_Rm_result{rm_result_ouch = rm_result_ouch obj} then P.Nothing else P.Just $ default_Rm_result{rm_result_ouch = rm_result_ouch obj}
    ]
from_Rm_result :: Rm_result -> T.ThriftVal
from_Rm_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v185 -> (1, ("ouch",from_ThriftIOException _v185))) <$> rm_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v185 -> P.Just (0, ("success",T.TBool _v185))) $ rm_result_success record
    , (\_v185 -> (1, ("ouch",from_ThriftIOException _v185))) <$> rm_result_ouch record
    ]
    )
write_Rm_result :: (T.Protocol p, T.Transport t) => p t -> Rm_result -> P.IO ()
write_Rm_result oprot record = T.writeVal oprot $ from_Rm_result record
encode_Rm_result :: (T.Protocol p, T.Transport t) => p t -> Rm_result -> LBS.ByteString
encode_Rm_result oprot record = T.serializeVal oprot $ from_Rm_result record
to_Rm_result :: T.ThriftVal -> Rm_result
to_Rm_result (T.TStruct fields) = Rm_result{
  rm_result_success = P.maybe (rm_result_success default_Rm_result) (\(_,_val187) -> (case _val187 of {T.TBool _val188 -> _val188; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  rm_result_ouch = P.maybe (P.Nothing) (\(_,_val187) -> P.Just (case _val187 of {T.TStruct _val189 -> (to_ThriftIOException (T.TStruct _val189)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Rm_result _ = P.error "not a struct"
read_Rm_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Rm_result
read_Rm_result iprot = to_Rm_result <$> T.readVal iprot (T.T_STRUCT typemap_Rm_result)
decode_Rm_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Rm_result
decode_Rm_result iprot bs = to_Rm_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Rm_result) bs
typemap_Rm_result :: T.TypeMap
typemap_Rm_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Rm_result :: Rm_result
default_Rm_result = Rm_result{
  rm_result_success = P.False,
  rm_result_ouch = P.Nothing}
data Rename_args = Rename_args  { rename_args_path :: Pathname
  , rename_args_dest :: Pathname
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Rename_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` rename_args_path record   `H.hashWithSalt` rename_args_dest record  
instance QC.Arbitrary Rename_args where 
  arbitrary = M.liftM Rename_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Rename_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Rename_args{rename_args_path = rename_args_path obj} then P.Nothing else P.Just $ default_Rename_args{rename_args_path = rename_args_path obj}
    , if obj == default_Rename_args{rename_args_dest = rename_args_dest obj} then P.Nothing else P.Just $ default_Rename_args{rename_args_dest = rename_args_dest obj}
    ]
from_Rename_args :: Rename_args -> T.ThriftVal
from_Rename_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v192 -> P.Just (1, ("path",from_Pathname _v192))) $ rename_args_path record
  , (\_v192 -> P.Just (2, ("dest",from_Pathname _v192))) $ rename_args_dest record
  ]
write_Rename_args :: (T.Protocol p, T.Transport t) => p t -> Rename_args -> P.IO ()
write_Rename_args oprot record = T.writeVal oprot $ from_Rename_args record
encode_Rename_args :: (T.Protocol p, T.Transport t) => p t -> Rename_args -> LBS.ByteString
encode_Rename_args oprot record = T.serializeVal oprot $ from_Rename_args record
to_Rename_args :: T.ThriftVal -> Rename_args
to_Rename_args (T.TStruct fields) = Rename_args{
  rename_args_path = P.maybe (rename_args_path default_Rename_args) (\(_,_val194) -> (case _val194 of {T.TStruct _val195 -> (to_Pathname (T.TStruct _val195)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  rename_args_dest = P.maybe (rename_args_dest default_Rename_args) (\(_,_val194) -> (case _val194 of {T.TStruct _val196 -> (to_Pathname (T.TStruct _val196)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Rename_args _ = P.error "not a struct"
read_Rename_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Rename_args
read_Rename_args iprot = to_Rename_args <$> T.readVal iprot (T.T_STRUCT typemap_Rename_args)
decode_Rename_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Rename_args
decode_Rename_args iprot bs = to_Rename_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Rename_args) bs
typemap_Rename_args :: T.TypeMap
typemap_Rename_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname))),(2,("dest",(T.T_STRUCT typemap_Pathname)))]
default_Rename_args :: Rename_args
default_Rename_args = Rename_args{
  rename_args_path = default_Pathname,
  rename_args_dest = default_Pathname}
data Rename_result = Rename_result  { rename_result_success :: P.Bool
  , rename_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Rename_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` rename_result_success record   `H.hashWithSalt` rename_result_ouch record  
instance QC.Arbitrary Rename_result where 
  arbitrary = M.liftM Rename_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Rename_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Rename_result{rename_result_success = rename_result_success obj} then P.Nothing else P.Just $ default_Rename_result{rename_result_success = rename_result_success obj}
    , if obj == default_Rename_result{rename_result_ouch = rename_result_ouch obj} then P.Nothing else P.Just $ default_Rename_result{rename_result_ouch = rename_result_ouch obj}
    ]
from_Rename_result :: Rename_result -> T.ThriftVal
from_Rename_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v199 -> (1, ("ouch",from_ThriftIOException _v199))) <$> rename_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v199 -> P.Just (0, ("success",T.TBool _v199))) $ rename_result_success record
    , (\_v199 -> (1, ("ouch",from_ThriftIOException _v199))) <$> rename_result_ouch record
    ]
    )
write_Rename_result :: (T.Protocol p, T.Transport t) => p t -> Rename_result -> P.IO ()
write_Rename_result oprot record = T.writeVal oprot $ from_Rename_result record
encode_Rename_result :: (T.Protocol p, T.Transport t) => p t -> Rename_result -> LBS.ByteString
encode_Rename_result oprot record = T.serializeVal oprot $ from_Rename_result record
to_Rename_result :: T.ThriftVal -> Rename_result
to_Rename_result (T.TStruct fields) = Rename_result{
  rename_result_success = P.maybe (rename_result_success default_Rename_result) (\(_,_val201) -> (case _val201 of {T.TBool _val202 -> _val202; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  rename_result_ouch = P.maybe (P.Nothing) (\(_,_val201) -> P.Just (case _val201 of {T.TStruct _val203 -> (to_ThriftIOException (T.TStruct _val203)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Rename_result _ = P.error "not a struct"
read_Rename_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Rename_result
read_Rename_result iprot = to_Rename_result <$> T.readVal iprot (T.T_STRUCT typemap_Rename_result)
decode_Rename_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Rename_result
decode_Rename_result iprot bs = to_Rename_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Rename_result) bs
typemap_Rename_result :: T.TypeMap
typemap_Rename_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Rename_result :: Rename_result
default_Rename_result = Rename_result{
  rename_result_success = P.False,
  rename_result_ouch = P.Nothing}
data Mkdirs_args = Mkdirs_args  { mkdirs_args_path :: Pathname
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Mkdirs_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` mkdirs_args_path record  
instance QC.Arbitrary Mkdirs_args where 
  arbitrary = M.liftM Mkdirs_args (QC.arbitrary)
  shrink obj | obj == default_Mkdirs_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Mkdirs_args{mkdirs_args_path = mkdirs_args_path obj} then P.Nothing else P.Just $ default_Mkdirs_args{mkdirs_args_path = mkdirs_args_path obj}
    ]
from_Mkdirs_args :: Mkdirs_args -> T.ThriftVal
from_Mkdirs_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v206 -> P.Just (1, ("path",from_Pathname _v206))) $ mkdirs_args_path record
  ]
write_Mkdirs_args :: (T.Protocol p, T.Transport t) => p t -> Mkdirs_args -> P.IO ()
write_Mkdirs_args oprot record = T.writeVal oprot $ from_Mkdirs_args record
encode_Mkdirs_args :: (T.Protocol p, T.Transport t) => p t -> Mkdirs_args -> LBS.ByteString
encode_Mkdirs_args oprot record = T.serializeVal oprot $ from_Mkdirs_args record
to_Mkdirs_args :: T.ThriftVal -> Mkdirs_args
to_Mkdirs_args (T.TStruct fields) = Mkdirs_args{
  mkdirs_args_path = P.maybe (mkdirs_args_path default_Mkdirs_args) (\(_,_val208) -> (case _val208 of {T.TStruct _val209 -> (to_Pathname (T.TStruct _val209)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Mkdirs_args _ = P.error "not a struct"
read_Mkdirs_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Mkdirs_args
read_Mkdirs_args iprot = to_Mkdirs_args <$> T.readVal iprot (T.T_STRUCT typemap_Mkdirs_args)
decode_Mkdirs_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Mkdirs_args
decode_Mkdirs_args iprot bs = to_Mkdirs_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Mkdirs_args) bs
typemap_Mkdirs_args :: T.TypeMap
typemap_Mkdirs_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname)))]
default_Mkdirs_args :: Mkdirs_args
default_Mkdirs_args = Mkdirs_args{
  mkdirs_args_path = default_Pathname}
data Mkdirs_result = Mkdirs_result  { mkdirs_result_success :: P.Bool
  , mkdirs_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Mkdirs_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` mkdirs_result_success record   `H.hashWithSalt` mkdirs_result_ouch record  
instance QC.Arbitrary Mkdirs_result where 
  arbitrary = M.liftM Mkdirs_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Mkdirs_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Mkdirs_result{mkdirs_result_success = mkdirs_result_success obj} then P.Nothing else P.Just $ default_Mkdirs_result{mkdirs_result_success = mkdirs_result_success obj}
    , if obj == default_Mkdirs_result{mkdirs_result_ouch = mkdirs_result_ouch obj} then P.Nothing else P.Just $ default_Mkdirs_result{mkdirs_result_ouch = mkdirs_result_ouch obj}
    ]
from_Mkdirs_result :: Mkdirs_result -> T.ThriftVal
from_Mkdirs_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v212 -> (1, ("ouch",from_ThriftIOException _v212))) <$> mkdirs_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v212 -> P.Just (0, ("success",T.TBool _v212))) $ mkdirs_result_success record
    , (\_v212 -> (1, ("ouch",from_ThriftIOException _v212))) <$> mkdirs_result_ouch record
    ]
    )
write_Mkdirs_result :: (T.Protocol p, T.Transport t) => p t -> Mkdirs_result -> P.IO ()
write_Mkdirs_result oprot record = T.writeVal oprot $ from_Mkdirs_result record
encode_Mkdirs_result :: (T.Protocol p, T.Transport t) => p t -> Mkdirs_result -> LBS.ByteString
encode_Mkdirs_result oprot record = T.serializeVal oprot $ from_Mkdirs_result record
to_Mkdirs_result :: T.ThriftVal -> Mkdirs_result
to_Mkdirs_result (T.TStruct fields) = Mkdirs_result{
  mkdirs_result_success = P.maybe (mkdirs_result_success default_Mkdirs_result) (\(_,_val214) -> (case _val214 of {T.TBool _val215 -> _val215; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  mkdirs_result_ouch = P.maybe (P.Nothing) (\(_,_val214) -> P.Just (case _val214 of {T.TStruct _val216 -> (to_ThriftIOException (T.TStruct _val216)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Mkdirs_result _ = P.error "not a struct"
read_Mkdirs_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Mkdirs_result
read_Mkdirs_result iprot = to_Mkdirs_result <$> T.readVal iprot (T.T_STRUCT typemap_Mkdirs_result)
decode_Mkdirs_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Mkdirs_result
decode_Mkdirs_result iprot bs = to_Mkdirs_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Mkdirs_result) bs
typemap_Mkdirs_result :: T.TypeMap
typemap_Mkdirs_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Mkdirs_result :: Mkdirs_result
default_Mkdirs_result = Mkdirs_result{
  mkdirs_result_success = P.False,
  mkdirs_result_ouch = P.Nothing}
data Exists_args = Exists_args  { exists_args_path :: Pathname
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Exists_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` exists_args_path record  
instance QC.Arbitrary Exists_args where 
  arbitrary = M.liftM Exists_args (QC.arbitrary)
  shrink obj | obj == default_Exists_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Exists_args{exists_args_path = exists_args_path obj} then P.Nothing else P.Just $ default_Exists_args{exists_args_path = exists_args_path obj}
    ]
from_Exists_args :: Exists_args -> T.ThriftVal
from_Exists_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v219 -> P.Just (1, ("path",from_Pathname _v219))) $ exists_args_path record
  ]
write_Exists_args :: (T.Protocol p, T.Transport t) => p t -> Exists_args -> P.IO ()
write_Exists_args oprot record = T.writeVal oprot $ from_Exists_args record
encode_Exists_args :: (T.Protocol p, T.Transport t) => p t -> Exists_args -> LBS.ByteString
encode_Exists_args oprot record = T.serializeVal oprot $ from_Exists_args record
to_Exists_args :: T.ThriftVal -> Exists_args
to_Exists_args (T.TStruct fields) = Exists_args{
  exists_args_path = P.maybe (exists_args_path default_Exists_args) (\(_,_val221) -> (case _val221 of {T.TStruct _val222 -> (to_Pathname (T.TStruct _val222)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Exists_args _ = P.error "not a struct"
read_Exists_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Exists_args
read_Exists_args iprot = to_Exists_args <$> T.readVal iprot (T.T_STRUCT typemap_Exists_args)
decode_Exists_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Exists_args
decode_Exists_args iprot bs = to_Exists_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Exists_args) bs
typemap_Exists_args :: T.TypeMap
typemap_Exists_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname)))]
default_Exists_args :: Exists_args
default_Exists_args = Exists_args{
  exists_args_path = default_Pathname}
data Exists_result = Exists_result  { exists_result_success :: P.Bool
  , exists_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Exists_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` exists_result_success record   `H.hashWithSalt` exists_result_ouch record  
instance QC.Arbitrary Exists_result where 
  arbitrary = M.liftM Exists_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Exists_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Exists_result{exists_result_success = exists_result_success obj} then P.Nothing else P.Just $ default_Exists_result{exists_result_success = exists_result_success obj}
    , if obj == default_Exists_result{exists_result_ouch = exists_result_ouch obj} then P.Nothing else P.Just $ default_Exists_result{exists_result_ouch = exists_result_ouch obj}
    ]
from_Exists_result :: Exists_result -> T.ThriftVal
from_Exists_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v225 -> (1, ("ouch",from_ThriftIOException _v225))) <$> exists_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v225 -> P.Just (0, ("success",T.TBool _v225))) $ exists_result_success record
    , (\_v225 -> (1, ("ouch",from_ThriftIOException _v225))) <$> exists_result_ouch record
    ]
    )
write_Exists_result :: (T.Protocol p, T.Transport t) => p t -> Exists_result -> P.IO ()
write_Exists_result oprot record = T.writeVal oprot $ from_Exists_result record
encode_Exists_result :: (T.Protocol p, T.Transport t) => p t -> Exists_result -> LBS.ByteString
encode_Exists_result oprot record = T.serializeVal oprot $ from_Exists_result record
to_Exists_result :: T.ThriftVal -> Exists_result
to_Exists_result (T.TStruct fields) = Exists_result{
  exists_result_success = P.maybe (exists_result_success default_Exists_result) (\(_,_val227) -> (case _val227 of {T.TBool _val228 -> _val228; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  exists_result_ouch = P.maybe (P.Nothing) (\(_,_val227) -> P.Just (case _val227 of {T.TStruct _val229 -> (to_ThriftIOException (T.TStruct _val229)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Exists_result _ = P.error "not a struct"
read_Exists_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Exists_result
read_Exists_result iprot = to_Exists_result <$> T.readVal iprot (T.T_STRUCT typemap_Exists_result)
decode_Exists_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Exists_result
decode_Exists_result iprot bs = to_Exists_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Exists_result) bs
typemap_Exists_result :: T.TypeMap
typemap_Exists_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Exists_result :: Exists_result
default_Exists_result = Exists_result{
  exists_result_success = P.False,
  exists_result_ouch = P.Nothing}
data Stat_args = Stat_args  { stat_args_path :: Pathname
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Stat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` stat_args_path record  
instance QC.Arbitrary Stat_args where 
  arbitrary = M.liftM Stat_args (QC.arbitrary)
  shrink obj | obj == default_Stat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Stat_args{stat_args_path = stat_args_path obj} then P.Nothing else P.Just $ default_Stat_args{stat_args_path = stat_args_path obj}
    ]
from_Stat_args :: Stat_args -> T.ThriftVal
from_Stat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v232 -> P.Just (1, ("path",from_Pathname _v232))) $ stat_args_path record
  ]
write_Stat_args :: (T.Protocol p, T.Transport t) => p t -> Stat_args -> P.IO ()
write_Stat_args oprot record = T.writeVal oprot $ from_Stat_args record
encode_Stat_args :: (T.Protocol p, T.Transport t) => p t -> Stat_args -> LBS.ByteString
encode_Stat_args oprot record = T.serializeVal oprot $ from_Stat_args record
to_Stat_args :: T.ThriftVal -> Stat_args
to_Stat_args (T.TStruct fields) = Stat_args{
  stat_args_path = P.maybe (stat_args_path default_Stat_args) (\(_,_val234) -> (case _val234 of {T.TStruct _val235 -> (to_Pathname (T.TStruct _val235)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Stat_args _ = P.error "not a struct"
read_Stat_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Stat_args
read_Stat_args iprot = to_Stat_args <$> T.readVal iprot (T.T_STRUCT typemap_Stat_args)
decode_Stat_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Stat_args
decode_Stat_args iprot bs = to_Stat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Stat_args) bs
typemap_Stat_args :: T.TypeMap
typemap_Stat_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname)))]
default_Stat_args :: Stat_args
default_Stat_args = Stat_args{
  stat_args_path = default_Pathname}
data Stat_result = Stat_result  { stat_result_success :: FileStatus
  , stat_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Stat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` stat_result_success record   `H.hashWithSalt` stat_result_ouch record  
instance QC.Arbitrary Stat_result where 
  arbitrary = M.liftM Stat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Stat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Stat_result{stat_result_success = stat_result_success obj} then P.Nothing else P.Just $ default_Stat_result{stat_result_success = stat_result_success obj}
    , if obj == default_Stat_result{stat_result_ouch = stat_result_ouch obj} then P.Nothing else P.Just $ default_Stat_result{stat_result_ouch = stat_result_ouch obj}
    ]
from_Stat_result :: Stat_result -> T.ThriftVal
from_Stat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v238 -> (1, ("ouch",from_ThriftIOException _v238))) <$> stat_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v238 -> P.Just (0, ("success",from_FileStatus _v238))) $ stat_result_success record
    , (\_v238 -> (1, ("ouch",from_ThriftIOException _v238))) <$> stat_result_ouch record
    ]
    )
write_Stat_result :: (T.Protocol p, T.Transport t) => p t -> Stat_result -> P.IO ()
write_Stat_result oprot record = T.writeVal oprot $ from_Stat_result record
encode_Stat_result :: (T.Protocol p, T.Transport t) => p t -> Stat_result -> LBS.ByteString
encode_Stat_result oprot record = T.serializeVal oprot $ from_Stat_result record
to_Stat_result :: T.ThriftVal -> Stat_result
to_Stat_result (T.TStruct fields) = Stat_result{
  stat_result_success = P.maybe (stat_result_success default_Stat_result) (\(_,_val240) -> (case _val240 of {T.TStruct _val241 -> (to_FileStatus (T.TStruct _val241)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  stat_result_ouch = P.maybe (P.Nothing) (\(_,_val240) -> P.Just (case _val240 of {T.TStruct _val242 -> (to_ThriftIOException (T.TStruct _val242)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Stat_result _ = P.error "not a struct"
read_Stat_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Stat_result
read_Stat_result iprot = to_Stat_result <$> T.readVal iprot (T.T_STRUCT typemap_Stat_result)
decode_Stat_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Stat_result
decode_Stat_result iprot bs = to_Stat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Stat_result) bs
typemap_Stat_result :: T.TypeMap
typemap_Stat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_FileStatus))),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Stat_result :: Stat_result
default_Stat_result = Stat_result{
  stat_result_success = default_FileStatus,
  stat_result_ouch = P.Nothing}
data ListStatus_args = ListStatus_args  { listStatus_args_path :: Pathname
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listStatus_args_path record  
instance QC.Arbitrary ListStatus_args where 
  arbitrary = M.liftM ListStatus_args (QC.arbitrary)
  shrink obj | obj == default_ListStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListStatus_args{listStatus_args_path = listStatus_args_path obj} then P.Nothing else P.Just $ default_ListStatus_args{listStatus_args_path = listStatus_args_path obj}
    ]
from_ListStatus_args :: ListStatus_args -> T.ThriftVal
from_ListStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v245 -> P.Just (1, ("path",from_Pathname _v245))) $ listStatus_args_path record
  ]
write_ListStatus_args :: (T.Protocol p, T.Transport t) => p t -> ListStatus_args -> P.IO ()
write_ListStatus_args oprot record = T.writeVal oprot $ from_ListStatus_args record
encode_ListStatus_args :: (T.Protocol p, T.Transport t) => p t -> ListStatus_args -> LBS.ByteString
encode_ListStatus_args oprot record = T.serializeVal oprot $ from_ListStatus_args record
to_ListStatus_args :: T.ThriftVal -> ListStatus_args
to_ListStatus_args (T.TStruct fields) = ListStatus_args{
  listStatus_args_path = P.maybe (listStatus_args_path default_ListStatus_args) (\(_,_val247) -> (case _val247 of {T.TStruct _val248 -> (to_Pathname (T.TStruct _val248)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListStatus_args _ = P.error "not a struct"
read_ListStatus_args :: (T.Transport t, T.Protocol p) => p t -> P.IO ListStatus_args
read_ListStatus_args iprot = to_ListStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_ListStatus_args)
decode_ListStatus_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ListStatus_args
decode_ListStatus_args iprot bs = to_ListStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListStatus_args) bs
typemap_ListStatus_args :: T.TypeMap
typemap_ListStatus_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname)))]
default_ListStatus_args :: ListStatus_args
default_ListStatus_args = ListStatus_args{
  listStatus_args_path = default_Pathname}
data ListStatus_result = ListStatus_result  { listStatus_result_success :: (Vector.Vector FileStatus)
  , listStatus_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listStatus_result_success record   `H.hashWithSalt` listStatus_result_ouch record  
instance QC.Arbitrary ListStatus_result where 
  arbitrary = M.liftM ListStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListStatus_result{listStatus_result_success = listStatus_result_success obj} then P.Nothing else P.Just $ default_ListStatus_result{listStatus_result_success = listStatus_result_success obj}
    , if obj == default_ListStatus_result{listStatus_result_ouch = listStatus_result_ouch obj} then P.Nothing else P.Just $ default_ListStatus_result{listStatus_result_ouch = listStatus_result_ouch obj}
    ]
from_ListStatus_result :: ListStatus_result -> T.ThriftVal
from_ListStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v251 -> (1, ("ouch",from_ThriftIOException _v251))) <$> listStatus_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v251 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_FileStatus) $ P.map (\_v253 -> from_FileStatus _v253) $ Vector.toList _v251))) $ listStatus_result_success record
    , (\_v251 -> (1, ("ouch",from_ThriftIOException _v251))) <$> listStatus_result_ouch record
    ]
    )
write_ListStatus_result :: (T.Protocol p, T.Transport t) => p t -> ListStatus_result -> P.IO ()
write_ListStatus_result oprot record = T.writeVal oprot $ from_ListStatus_result record
encode_ListStatus_result :: (T.Protocol p, T.Transport t) => p t -> ListStatus_result -> LBS.ByteString
encode_ListStatus_result oprot record = T.serializeVal oprot $ from_ListStatus_result record
to_ListStatus_result :: T.ThriftVal -> ListStatus_result
to_ListStatus_result (T.TStruct fields) = ListStatus_result{
  listStatus_result_success = P.maybe (listStatus_result_success default_ListStatus_result) (\(_,_val255) -> (case _val255 of {T.TList _ _val256 -> (Vector.fromList $ P.map (\_v257 -> (case _v257 of {T.TStruct _val258 -> (to_FileStatus (T.TStruct _val258)); _ -> P.error "wrong type"})) _val256); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listStatus_result_ouch = P.maybe (P.Nothing) (\(_,_val255) -> P.Just (case _val255 of {T.TStruct _val259 -> (to_ThriftIOException (T.TStruct _val259)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListStatus_result _ = P.error "not a struct"
read_ListStatus_result :: (T.Transport t, T.Protocol p) => p t -> P.IO ListStatus_result
read_ListStatus_result iprot = to_ListStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_ListStatus_result)
decode_ListStatus_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> ListStatus_result
decode_ListStatus_result iprot bs = to_ListStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListStatus_result) bs
typemap_ListStatus_result :: T.TypeMap
typemap_ListStatus_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_FileStatus)))),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_ListStatus_result :: ListStatus_result
default_ListStatus_result = ListStatus_result{
  listStatus_result_success = Vector.empty,
  listStatus_result_ouch = P.Nothing}
data Chmod_args = Chmod_args  { chmod_args_path :: Pathname
  , chmod_args_mode :: I.Int16
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Chmod_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` chmod_args_path record   `H.hashWithSalt` chmod_args_mode record  
instance QC.Arbitrary Chmod_args where 
  arbitrary = M.liftM Chmod_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Chmod_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Chmod_args{chmod_args_path = chmod_args_path obj} then P.Nothing else P.Just $ default_Chmod_args{chmod_args_path = chmod_args_path obj}
    , if obj == default_Chmod_args{chmod_args_mode = chmod_args_mode obj} then P.Nothing else P.Just $ default_Chmod_args{chmod_args_mode = chmod_args_mode obj}
    ]
from_Chmod_args :: Chmod_args -> T.ThriftVal
from_Chmod_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v262 -> P.Just (1, ("path",from_Pathname _v262))) $ chmod_args_path record
  , (\_v262 -> P.Just (2, ("mode",T.TI16 _v262))) $ chmod_args_mode record
  ]
write_Chmod_args :: (T.Protocol p, T.Transport t) => p t -> Chmod_args -> P.IO ()
write_Chmod_args oprot record = T.writeVal oprot $ from_Chmod_args record
encode_Chmod_args :: (T.Protocol p, T.Transport t) => p t -> Chmod_args -> LBS.ByteString
encode_Chmod_args oprot record = T.serializeVal oprot $ from_Chmod_args record
to_Chmod_args :: T.ThriftVal -> Chmod_args
to_Chmod_args (T.TStruct fields) = Chmod_args{
  chmod_args_path = P.maybe (chmod_args_path default_Chmod_args) (\(_,_val264) -> (case _val264 of {T.TStruct _val265 -> (to_Pathname (T.TStruct _val265)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  chmod_args_mode = P.maybe (chmod_args_mode default_Chmod_args) (\(_,_val264) -> (case _val264 of {T.TI16 _val266 -> _val266; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Chmod_args _ = P.error "not a struct"
read_Chmod_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Chmod_args
read_Chmod_args iprot = to_Chmod_args <$> T.readVal iprot (T.T_STRUCT typemap_Chmod_args)
decode_Chmod_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Chmod_args
decode_Chmod_args iprot bs = to_Chmod_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Chmod_args) bs
typemap_Chmod_args :: T.TypeMap
typemap_Chmod_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname))),(2,("mode",T.T_I16))]
default_Chmod_args :: Chmod_args
default_Chmod_args = Chmod_args{
  chmod_args_path = default_Pathname,
  chmod_args_mode = 0}
data Chmod_result = Chmod_result  { chmod_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Chmod_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` chmod_result_ouch record  
instance QC.Arbitrary Chmod_result where 
  arbitrary = M.liftM Chmod_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Chmod_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Chmod_result{chmod_result_ouch = chmod_result_ouch obj} then P.Nothing else P.Just $ default_Chmod_result{chmod_result_ouch = chmod_result_ouch obj}
    ]
from_Chmod_result :: Chmod_result -> T.ThriftVal
from_Chmod_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v269 -> (1, ("ouch",from_ThriftIOException _v269))) <$> chmod_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v269 -> (1, ("ouch",from_ThriftIOException _v269))) <$> chmod_result_ouch record
    ]
    )
write_Chmod_result :: (T.Protocol p, T.Transport t) => p t -> Chmod_result -> P.IO ()
write_Chmod_result oprot record = T.writeVal oprot $ from_Chmod_result record
encode_Chmod_result :: (T.Protocol p, T.Transport t) => p t -> Chmod_result -> LBS.ByteString
encode_Chmod_result oprot record = T.serializeVal oprot $ from_Chmod_result record
to_Chmod_result :: T.ThriftVal -> Chmod_result
to_Chmod_result (T.TStruct fields) = Chmod_result{
  chmod_result_ouch = P.maybe (P.Nothing) (\(_,_val271) -> P.Just (case _val271 of {T.TStruct _val272 -> (to_ThriftIOException (T.TStruct _val272)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Chmod_result _ = P.error "not a struct"
read_Chmod_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Chmod_result
read_Chmod_result iprot = to_Chmod_result <$> T.readVal iprot (T.T_STRUCT typemap_Chmod_result)
decode_Chmod_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Chmod_result
decode_Chmod_result iprot bs = to_Chmod_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Chmod_result) bs
typemap_Chmod_result :: T.TypeMap
typemap_Chmod_result = Map.fromList [(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Chmod_result :: Chmod_result
default_Chmod_result = Chmod_result{
  chmod_result_ouch = P.Nothing}
data Chown_args = Chown_args  { chown_args_path :: Pathname
  , chown_args_owner :: LT.Text
  , chown_args_group :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Chown_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` chown_args_path record   `H.hashWithSalt` chown_args_owner record   `H.hashWithSalt` chown_args_group record  
instance QC.Arbitrary Chown_args where 
  arbitrary = M.liftM Chown_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Chown_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Chown_args{chown_args_path = chown_args_path obj} then P.Nothing else P.Just $ default_Chown_args{chown_args_path = chown_args_path obj}
    , if obj == default_Chown_args{chown_args_owner = chown_args_owner obj} then P.Nothing else P.Just $ default_Chown_args{chown_args_owner = chown_args_owner obj}
    , if obj == default_Chown_args{chown_args_group = chown_args_group obj} then P.Nothing else P.Just $ default_Chown_args{chown_args_group = chown_args_group obj}
    ]
from_Chown_args :: Chown_args -> T.ThriftVal
from_Chown_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v275 -> P.Just (1, ("path",from_Pathname _v275))) $ chown_args_path record
  , (\_v275 -> P.Just (2, ("owner",T.TString $ E.encodeUtf8 _v275))) $ chown_args_owner record
  , (\_v275 -> P.Just (3, ("group",T.TString $ E.encodeUtf8 _v275))) $ chown_args_group record
  ]
write_Chown_args :: (T.Protocol p, T.Transport t) => p t -> Chown_args -> P.IO ()
write_Chown_args oprot record = T.writeVal oprot $ from_Chown_args record
encode_Chown_args :: (T.Protocol p, T.Transport t) => p t -> Chown_args -> LBS.ByteString
encode_Chown_args oprot record = T.serializeVal oprot $ from_Chown_args record
to_Chown_args :: T.ThriftVal -> Chown_args
to_Chown_args (T.TStruct fields) = Chown_args{
  chown_args_path = P.maybe (chown_args_path default_Chown_args) (\(_,_val277) -> (case _val277 of {T.TStruct _val278 -> (to_Pathname (T.TStruct _val278)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  chown_args_owner = P.maybe (chown_args_owner default_Chown_args) (\(_,_val277) -> (case _val277 of {T.TString _val279 -> E.decodeUtf8 _val279; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  chown_args_group = P.maybe (chown_args_group default_Chown_args) (\(_,_val277) -> (case _val277 of {T.TString _val280 -> E.decodeUtf8 _val280; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Chown_args _ = P.error "not a struct"
read_Chown_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Chown_args
read_Chown_args iprot = to_Chown_args <$> T.readVal iprot (T.T_STRUCT typemap_Chown_args)
decode_Chown_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Chown_args
decode_Chown_args iprot bs = to_Chown_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Chown_args) bs
typemap_Chown_args :: T.TypeMap
typemap_Chown_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname))),(2,("owner",T.T_STRING)),(3,("group",T.T_STRING))]
default_Chown_args :: Chown_args
default_Chown_args = Chown_args{
  chown_args_path = default_Pathname,
  chown_args_owner = "",
  chown_args_group = ""}
data Chown_result = Chown_result  { chown_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Chown_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` chown_result_ouch record  
instance QC.Arbitrary Chown_result where 
  arbitrary = M.liftM Chown_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Chown_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Chown_result{chown_result_ouch = chown_result_ouch obj} then P.Nothing else P.Just $ default_Chown_result{chown_result_ouch = chown_result_ouch obj}
    ]
from_Chown_result :: Chown_result -> T.ThriftVal
from_Chown_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v283 -> (1, ("ouch",from_ThriftIOException _v283))) <$> chown_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v283 -> (1, ("ouch",from_ThriftIOException _v283))) <$> chown_result_ouch record
    ]
    )
write_Chown_result :: (T.Protocol p, T.Transport t) => p t -> Chown_result -> P.IO ()
write_Chown_result oprot record = T.writeVal oprot $ from_Chown_result record
encode_Chown_result :: (T.Protocol p, T.Transport t) => p t -> Chown_result -> LBS.ByteString
encode_Chown_result oprot record = T.serializeVal oprot $ from_Chown_result record
to_Chown_result :: T.ThriftVal -> Chown_result
to_Chown_result (T.TStruct fields) = Chown_result{
  chown_result_ouch = P.maybe (P.Nothing) (\(_,_val285) -> P.Just (case _val285 of {T.TStruct _val286 -> (to_ThriftIOException (T.TStruct _val286)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Chown_result _ = P.error "not a struct"
read_Chown_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Chown_result
read_Chown_result iprot = to_Chown_result <$> T.readVal iprot (T.T_STRUCT typemap_Chown_result)
decode_Chown_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Chown_result
decode_Chown_result iprot bs = to_Chown_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Chown_result) bs
typemap_Chown_result :: T.TypeMap
typemap_Chown_result = Map.fromList [(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_Chown_result :: Chown_result
default_Chown_result = Chown_result{
  chown_result_ouch = P.Nothing}
data SetReplication_args = SetReplication_args  { setReplication_args_path :: Pathname
  , setReplication_args_replication :: I.Int16
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetReplication_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setReplication_args_path record   `H.hashWithSalt` setReplication_args_replication record  
instance QC.Arbitrary SetReplication_args where 
  arbitrary = M.liftM SetReplication_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetReplication_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetReplication_args{setReplication_args_path = setReplication_args_path obj} then P.Nothing else P.Just $ default_SetReplication_args{setReplication_args_path = setReplication_args_path obj}
    , if obj == default_SetReplication_args{setReplication_args_replication = setReplication_args_replication obj} then P.Nothing else P.Just $ default_SetReplication_args{setReplication_args_replication = setReplication_args_replication obj}
    ]
from_SetReplication_args :: SetReplication_args -> T.ThriftVal
from_SetReplication_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v289 -> P.Just (1, ("path",from_Pathname _v289))) $ setReplication_args_path record
  , (\_v289 -> P.Just (2, ("replication",T.TI16 _v289))) $ setReplication_args_replication record
  ]
write_SetReplication_args :: (T.Protocol p, T.Transport t) => p t -> SetReplication_args -> P.IO ()
write_SetReplication_args oprot record = T.writeVal oprot $ from_SetReplication_args record
encode_SetReplication_args :: (T.Protocol p, T.Transport t) => p t -> SetReplication_args -> LBS.ByteString
encode_SetReplication_args oprot record = T.serializeVal oprot $ from_SetReplication_args record
to_SetReplication_args :: T.ThriftVal -> SetReplication_args
to_SetReplication_args (T.TStruct fields) = SetReplication_args{
  setReplication_args_path = P.maybe (setReplication_args_path default_SetReplication_args) (\(_,_val291) -> (case _val291 of {T.TStruct _val292 -> (to_Pathname (T.TStruct _val292)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setReplication_args_replication = P.maybe (setReplication_args_replication default_SetReplication_args) (\(_,_val291) -> (case _val291 of {T.TI16 _val293 -> _val293; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SetReplication_args _ = P.error "not a struct"
read_SetReplication_args :: (T.Transport t, T.Protocol p) => p t -> P.IO SetReplication_args
read_SetReplication_args iprot = to_SetReplication_args <$> T.readVal iprot (T.T_STRUCT typemap_SetReplication_args)
decode_SetReplication_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SetReplication_args
decode_SetReplication_args iprot bs = to_SetReplication_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetReplication_args) bs
typemap_SetReplication_args :: T.TypeMap
typemap_SetReplication_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname))),(2,("replication",T.T_I16))]
default_SetReplication_args :: SetReplication_args
default_SetReplication_args = SetReplication_args{
  setReplication_args_path = default_Pathname,
  setReplication_args_replication = 0}
data SetReplication_result = SetReplication_result  { setReplication_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetReplication_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setReplication_result_ouch record  
instance QC.Arbitrary SetReplication_result where 
  arbitrary = M.liftM SetReplication_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetReplication_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetReplication_result{setReplication_result_ouch = setReplication_result_ouch obj} then P.Nothing else P.Just $ default_SetReplication_result{setReplication_result_ouch = setReplication_result_ouch obj}
    ]
from_SetReplication_result :: SetReplication_result -> T.ThriftVal
from_SetReplication_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v296 -> (1, ("ouch",from_ThriftIOException _v296))) <$> setReplication_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v296 -> (1, ("ouch",from_ThriftIOException _v296))) <$> setReplication_result_ouch record
    ]
    )
write_SetReplication_result :: (T.Protocol p, T.Transport t) => p t -> SetReplication_result -> P.IO ()
write_SetReplication_result oprot record = T.writeVal oprot $ from_SetReplication_result record
encode_SetReplication_result :: (T.Protocol p, T.Transport t) => p t -> SetReplication_result -> LBS.ByteString
encode_SetReplication_result oprot record = T.serializeVal oprot $ from_SetReplication_result record
to_SetReplication_result :: T.ThriftVal -> SetReplication_result
to_SetReplication_result (T.TStruct fields) = SetReplication_result{
  setReplication_result_ouch = P.maybe (P.Nothing) (\(_,_val298) -> P.Just (case _val298 of {T.TStruct _val299 -> (to_ThriftIOException (T.TStruct _val299)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SetReplication_result _ = P.error "not a struct"
read_SetReplication_result :: (T.Transport t, T.Protocol p) => p t -> P.IO SetReplication_result
read_SetReplication_result iprot = to_SetReplication_result <$> T.readVal iprot (T.T_STRUCT typemap_SetReplication_result)
decode_SetReplication_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> SetReplication_result
decode_SetReplication_result iprot bs = to_SetReplication_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetReplication_result) bs
typemap_SetReplication_result :: T.TypeMap
typemap_SetReplication_result = Map.fromList [(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_SetReplication_result :: SetReplication_result
default_SetReplication_result = SetReplication_result{
  setReplication_result_ouch = P.Nothing}
data GetFileBlockLocations_args = GetFileBlockLocations_args  { getFileBlockLocations_args_path :: Pathname
  , getFileBlockLocations_args_start :: I.Int64
  , getFileBlockLocations_args_length :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFileBlockLocations_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFileBlockLocations_args_path record   `H.hashWithSalt` getFileBlockLocations_args_start record   `H.hashWithSalt` getFileBlockLocations_args_length record  
instance QC.Arbitrary GetFileBlockLocations_args where 
  arbitrary = M.liftM GetFileBlockLocations_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetFileBlockLocations_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFileBlockLocations_args{getFileBlockLocations_args_path = getFileBlockLocations_args_path obj} then P.Nothing else P.Just $ default_GetFileBlockLocations_args{getFileBlockLocations_args_path = getFileBlockLocations_args_path obj}
    , if obj == default_GetFileBlockLocations_args{getFileBlockLocations_args_start = getFileBlockLocations_args_start obj} then P.Nothing else P.Just $ default_GetFileBlockLocations_args{getFileBlockLocations_args_start = getFileBlockLocations_args_start obj}
    , if obj == default_GetFileBlockLocations_args{getFileBlockLocations_args_length = getFileBlockLocations_args_length obj} then P.Nothing else P.Just $ default_GetFileBlockLocations_args{getFileBlockLocations_args_length = getFileBlockLocations_args_length obj}
    ]
from_GetFileBlockLocations_args :: GetFileBlockLocations_args -> T.ThriftVal
from_GetFileBlockLocations_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v302 -> P.Just (1, ("path",from_Pathname _v302))) $ getFileBlockLocations_args_path record
  , (\_v302 -> P.Just (2, ("start",T.TI64 _v302))) $ getFileBlockLocations_args_start record
  , (\_v302 -> P.Just (3, ("length",T.TI64 _v302))) $ getFileBlockLocations_args_length record
  ]
write_GetFileBlockLocations_args :: (T.Protocol p, T.Transport t) => p t -> GetFileBlockLocations_args -> P.IO ()
write_GetFileBlockLocations_args oprot record = T.writeVal oprot $ from_GetFileBlockLocations_args record
encode_GetFileBlockLocations_args :: (T.Protocol p, T.Transport t) => p t -> GetFileBlockLocations_args -> LBS.ByteString
encode_GetFileBlockLocations_args oprot record = T.serializeVal oprot $ from_GetFileBlockLocations_args record
to_GetFileBlockLocations_args :: T.ThriftVal -> GetFileBlockLocations_args
to_GetFileBlockLocations_args (T.TStruct fields) = GetFileBlockLocations_args{
  getFileBlockLocations_args_path = P.maybe (getFileBlockLocations_args_path default_GetFileBlockLocations_args) (\(_,_val304) -> (case _val304 of {T.TStruct _val305 -> (to_Pathname (T.TStruct _val305)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getFileBlockLocations_args_start = P.maybe (getFileBlockLocations_args_start default_GetFileBlockLocations_args) (\(_,_val304) -> (case _val304 of {T.TI64 _val306 -> _val306; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getFileBlockLocations_args_length = P.maybe (getFileBlockLocations_args_length default_GetFileBlockLocations_args) (\(_,_val304) -> (case _val304 of {T.TI64 _val307 -> _val307; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetFileBlockLocations_args _ = P.error "not a struct"
read_GetFileBlockLocations_args :: (T.Transport t, T.Protocol p) => p t -> P.IO GetFileBlockLocations_args
read_GetFileBlockLocations_args iprot = to_GetFileBlockLocations_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFileBlockLocations_args)
decode_GetFileBlockLocations_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetFileBlockLocations_args
decode_GetFileBlockLocations_args iprot bs = to_GetFileBlockLocations_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFileBlockLocations_args) bs
typemap_GetFileBlockLocations_args :: T.TypeMap
typemap_GetFileBlockLocations_args = Map.fromList [(1,("path",(T.T_STRUCT typemap_Pathname))),(2,("start",T.T_I64)),(3,("length",T.T_I64))]
default_GetFileBlockLocations_args :: GetFileBlockLocations_args
default_GetFileBlockLocations_args = GetFileBlockLocations_args{
  getFileBlockLocations_args_path = default_Pathname,
  getFileBlockLocations_args_start = 0,
  getFileBlockLocations_args_length = 0}
data GetFileBlockLocations_result = GetFileBlockLocations_result  { getFileBlockLocations_result_success :: (Vector.Vector BlockLocation)
  , getFileBlockLocations_result_ouch :: P.Maybe ThriftIOException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFileBlockLocations_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFileBlockLocations_result_success record   `H.hashWithSalt` getFileBlockLocations_result_ouch record  
instance QC.Arbitrary GetFileBlockLocations_result where 
  arbitrary = M.liftM GetFileBlockLocations_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFileBlockLocations_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFileBlockLocations_result{getFileBlockLocations_result_success = getFileBlockLocations_result_success obj} then P.Nothing else P.Just $ default_GetFileBlockLocations_result{getFileBlockLocations_result_success = getFileBlockLocations_result_success obj}
    , if obj == default_GetFileBlockLocations_result{getFileBlockLocations_result_ouch = getFileBlockLocations_result_ouch obj} then P.Nothing else P.Just $ default_GetFileBlockLocations_result{getFileBlockLocations_result_ouch = getFileBlockLocations_result_ouch obj}
    ]
from_GetFileBlockLocations_result :: GetFileBlockLocations_result -> T.ThriftVal
from_GetFileBlockLocations_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v310 -> (1, ("ouch",from_ThriftIOException _v310))) <$> getFileBlockLocations_result_ouch record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v310 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_BlockLocation) $ P.map (\_v312 -> from_BlockLocation _v312) $ Vector.toList _v310))) $ getFileBlockLocations_result_success record
    , (\_v310 -> (1, ("ouch",from_ThriftIOException _v310))) <$> getFileBlockLocations_result_ouch record
    ]
    )
write_GetFileBlockLocations_result :: (T.Protocol p, T.Transport t) => p t -> GetFileBlockLocations_result -> P.IO ()
write_GetFileBlockLocations_result oprot record = T.writeVal oprot $ from_GetFileBlockLocations_result record
encode_GetFileBlockLocations_result :: (T.Protocol p, T.Transport t) => p t -> GetFileBlockLocations_result -> LBS.ByteString
encode_GetFileBlockLocations_result oprot record = T.serializeVal oprot $ from_GetFileBlockLocations_result record
to_GetFileBlockLocations_result :: T.ThriftVal -> GetFileBlockLocations_result
to_GetFileBlockLocations_result (T.TStruct fields) = GetFileBlockLocations_result{
  getFileBlockLocations_result_success = P.maybe (getFileBlockLocations_result_success default_GetFileBlockLocations_result) (\(_,_val314) -> (case _val314 of {T.TList _ _val315 -> (Vector.fromList $ P.map (\_v316 -> (case _v316 of {T.TStruct _val317 -> (to_BlockLocation (T.TStruct _val317)); _ -> P.error "wrong type"})) _val315); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFileBlockLocations_result_ouch = P.maybe (P.Nothing) (\(_,_val314) -> P.Just (case _val314 of {T.TStruct _val318 -> (to_ThriftIOException (T.TStruct _val318)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFileBlockLocations_result _ = P.error "not a struct"
read_GetFileBlockLocations_result :: (T.Transport t, T.Protocol p) => p t -> P.IO GetFileBlockLocations_result
read_GetFileBlockLocations_result iprot = to_GetFileBlockLocations_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFileBlockLocations_result)
decode_GetFileBlockLocations_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> GetFileBlockLocations_result
decode_GetFileBlockLocations_result iprot bs = to_GetFileBlockLocations_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFileBlockLocations_result) bs
typemap_GetFileBlockLocations_result :: T.TypeMap
typemap_GetFileBlockLocations_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_BlockLocation)))),(1,("ouch",(T.T_STRUCT typemap_ThriftIOException)))]
default_GetFileBlockLocations_result :: GetFileBlockLocations_result
default_GetFileBlockLocations_result = GetFileBlockLocations_result{
  getFileBlockLocations_result_success = Vector.empty,
  getFileBlockLocations_result_ouch = P.Nothing}
process_setInactivityTimeoutPeriod (seqid, iprot, oprot, handler) = do
  args <- read_SetInactivityTimeoutPeriod_args iprot
  (X.catch
    (do
      Iface.setInactivityTimeoutPeriod handler (setInactivityTimeoutPeriod_args_periodInSeconds args)
      let res = default_SetInactivityTimeoutPeriod_result
      T.writeMessageBegin oprot ("setInactivityTimeoutPeriod", T.M_REPLY, seqid)
      write_SetInactivityTimeoutPeriod_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("setInactivityTimeoutPeriod", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_shutdown (seqid, iprot, oprot, handler) = do
  args <- read_Shutdown_args iprot
  (X.catch
    (do
      Iface.shutdown handler (shutdown_args_status args)
      let res = default_Shutdown_result
      T.writeMessageBegin oprot ("shutdown", T.M_REPLY, seqid)
      write_Shutdown_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("shutdown", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_create (seqid, iprot, oprot, handler) = do
  args <- read_Create_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.create handler (create_args_path args)
        let res = default_Create_result{create_result_success = val}
        T.writeMessageBegin oprot ("create", T.M_REPLY, seqid)
        write_Create_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Create_result{create_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("create", T.M_REPLY, seqid)
        write_Create_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("create", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_createFile (seqid, iprot, oprot, handler) = do
  args <- read_CreateFile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createFile handler (createFile_args_path args) (createFile_args_mode args) (createFile_args_overwrite args) (createFile_args_bufferSize args) (createFile_args_block_replication args) (createFile_args_blocksize args)
        let res = default_CreateFile_result{createFile_result_success = val}
        T.writeMessageBegin oprot ("createFile", T.M_REPLY, seqid)
        write_CreateFile_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_CreateFile_result{createFile_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("createFile", T.M_REPLY, seqid)
        write_CreateFile_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("createFile", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_open (seqid, iprot, oprot, handler) = do
  args <- read_Open_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.open handler (open_args_path args)
        let res = default_Open_result{open_result_success = val}
        T.writeMessageBegin oprot ("open", T.M_REPLY, seqid)
        write_Open_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Open_result{open_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("open", T.M_REPLY, seqid)
        write_Open_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("open", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_append (seqid, iprot, oprot, handler) = do
  args <- read_Append_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.append handler (append_args_path args)
        let res = default_Append_result{append_result_success = val}
        T.writeMessageBegin oprot ("append", T.M_REPLY, seqid)
        write_Append_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Append_result{append_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("append", T.M_REPLY, seqid)
        write_Append_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("append", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_write (seqid, iprot, oprot, handler) = do
  args <- read_Write_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.write handler (write_args_handle args) (write_args_data args)
        let res = default_Write_result{write_result_success = val}
        T.writeMessageBegin oprot ("write", T.M_REPLY, seqid)
        write_Write_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Write_result{write_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("write", T.M_REPLY, seqid)
        write_Write_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("write", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_read (seqid, iprot, oprot, handler) = do
  args <- read_Read_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.read handler (read_args_handle args) (read_args_offset args) (read_args_size args)
        let res = default_Read_result{read_result_success = val}
        T.writeMessageBegin oprot ("read", T.M_REPLY, seqid)
        write_Read_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Read_result{read_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("read", T.M_REPLY, seqid)
        write_Read_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("read", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_close (seqid, iprot, oprot, handler) = do
  args <- read_Close_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.close handler (close_args_out args)
        let res = default_Close_result{close_result_success = val}
        T.writeMessageBegin oprot ("close", T.M_REPLY, seqid)
        write_Close_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Close_result{close_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("close", T.M_REPLY, seqid)
        write_Close_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("close", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_rm (seqid, iprot, oprot, handler) = do
  args <- read_Rm_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.rm handler (rm_args_path args) (rm_args_recursive args)
        let res = default_Rm_result{rm_result_success = val}
        T.writeMessageBegin oprot ("rm", T.M_REPLY, seqid)
        write_Rm_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Rm_result{rm_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("rm", T.M_REPLY, seqid)
        write_Rm_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("rm", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_rename (seqid, iprot, oprot, handler) = do
  args <- read_Rename_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.rename handler (rename_args_path args) (rename_args_dest args)
        let res = default_Rename_result{rename_result_success = val}
        T.writeMessageBegin oprot ("rename", T.M_REPLY, seqid)
        write_Rename_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Rename_result{rename_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("rename", T.M_REPLY, seqid)
        write_Rename_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("rename", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_mkdirs (seqid, iprot, oprot, handler) = do
  args <- read_Mkdirs_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.mkdirs handler (mkdirs_args_path args)
        let res = default_Mkdirs_result{mkdirs_result_success = val}
        T.writeMessageBegin oprot ("mkdirs", T.M_REPLY, seqid)
        write_Mkdirs_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Mkdirs_result{mkdirs_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("mkdirs", T.M_REPLY, seqid)
        write_Mkdirs_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("mkdirs", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_exists (seqid, iprot, oprot, handler) = do
  args <- read_Exists_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.exists handler (exists_args_path args)
        let res = default_Exists_result{exists_result_success = val}
        T.writeMessageBegin oprot ("exists", T.M_REPLY, seqid)
        write_Exists_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Exists_result{exists_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("exists", T.M_REPLY, seqid)
        write_Exists_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("exists", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_stat (seqid, iprot, oprot, handler) = do
  args <- read_Stat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.stat handler (stat_args_path args)
        let res = default_Stat_result{stat_result_success = val}
        T.writeMessageBegin oprot ("stat", T.M_REPLY, seqid)
        write_Stat_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Stat_result{stat_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("stat", T.M_REPLY, seqid)
        write_Stat_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("stat", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_listStatus (seqid, iprot, oprot, handler) = do
  args <- read_ListStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.listStatus handler (listStatus_args_path args)
        let res = default_ListStatus_result{listStatus_result_success = val}
        T.writeMessageBegin oprot ("listStatus", T.M_REPLY, seqid)
        write_ListStatus_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_ListStatus_result{listStatus_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("listStatus", T.M_REPLY, seqid)
        write_ListStatus_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("listStatus", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_chmod (seqid, iprot, oprot, handler) = do
  args <- read_Chmod_args iprot
  (X.catch
    (X.catch
      (do
        Iface.chmod handler (chmod_args_path args) (chmod_args_mode args)
        let res = default_Chmod_result
        T.writeMessageBegin oprot ("chmod", T.M_REPLY, seqid)
        write_Chmod_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Chmod_result{chmod_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("chmod", T.M_REPLY, seqid)
        write_Chmod_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("chmod", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_chown (seqid, iprot, oprot, handler) = do
  args <- read_Chown_args iprot
  (X.catch
    (X.catch
      (do
        Iface.chown handler (chown_args_path args) (chown_args_owner args) (chown_args_group args)
        let res = default_Chown_result
        T.writeMessageBegin oprot ("chown", T.M_REPLY, seqid)
        write_Chown_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_Chown_result{chown_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("chown", T.M_REPLY, seqid)
        write_Chown_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("chown", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_setReplication (seqid, iprot, oprot, handler) = do
  args <- read_SetReplication_args iprot
  (X.catch
    (X.catch
      (do
        Iface.setReplication handler (setReplication_args_path args) (setReplication_args_replication args)
        let res = default_SetReplication_result
        T.writeMessageBegin oprot ("setReplication", T.M_REPLY, seqid)
        write_SetReplication_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_SetReplication_result{setReplication_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("setReplication", T.M_REPLY, seqid)
        write_SetReplication_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("setReplication", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_getFileBlockLocations (seqid, iprot, oprot, handler) = do
  args <- read_GetFileBlockLocations_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFileBlockLocations handler (getFileBlockLocations_args_path args) (getFileBlockLocations_args_start args) (getFileBlockLocations_args_length args)
        let res = default_GetFileBlockLocations_result{getFileBlockLocations_result_success = val}
        T.writeMessageBegin oprot ("getFileBlockLocations", T.M_REPLY, seqid)
        write_GetFileBlockLocations_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot))
      (\e  -> do
        let res = default_GetFileBlockLocations_result{getFileBlockLocations_result_ouch = P.Just e}
        T.writeMessageBegin oprot ("getFileBlockLocations", T.M_REPLY, seqid)
        write_GetFileBlockLocations_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("getFileBlockLocations", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "setInactivityTimeoutPeriod" -> process_setInactivityTimeoutPeriod (seqid,iprot,oprot,handler)
  "shutdown" -> process_shutdown (seqid,iprot,oprot,handler)
  "create" -> process_create (seqid,iprot,oprot,handler)
  "createFile" -> process_createFile (seqid,iprot,oprot,handler)
  "open" -> process_open (seqid,iprot,oprot,handler)
  "append" -> process_append (seqid,iprot,oprot,handler)
  "write" -> process_write (seqid,iprot,oprot,handler)
  "read" -> process_read (seqid,iprot,oprot,handler)
  "close" -> process_close (seqid,iprot,oprot,handler)
  "rm" -> process_rm (seqid,iprot,oprot,handler)
  "rename" -> process_rename (seqid,iprot,oprot,handler)
  "mkdirs" -> process_mkdirs (seqid,iprot,oprot,handler)
  "exists" -> process_exists (seqid,iprot,oprot,handler)
  "stat" -> process_stat (seqid,iprot,oprot,handler)
  "listStatus" -> process_listStatus (seqid,iprot,oprot,handler)
  "chmod" -> process_chmod (seqid,iprot,oprot,handler)
  "chown" -> process_chown (seqid,iprot,oprot,handler)
  "setReplication" -> process_setReplication (seqid,iprot,oprot,handler)
  "getFileBlockLocations" -> process_getFileBlockLocations (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
